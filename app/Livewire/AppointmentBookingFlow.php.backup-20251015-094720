<?php

namespace App\Livewire;

use Livewire\Component;
use App\Services\Appointments\WeeklyAvailabilityService;
use App\Models\Service;
use App\Models\Staff;
use Carbon\Carbon;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;
use App\Exceptions\CalcomApiException;

/**
 * AppointmentBookingFlow
 *
 * Modern appointment booking component with service-first approach
 *
 * Key Features:
 * - Service selection FIRST (with duration awareness)
 * - Employee preference (optional, defaults to "any")
 * - Duration-aware slot calculation
 * - Single-page vertical layout
 * - Professional Filament-consistent UI
 *
 * Flow:
 * 1. User selects service (default: Damenhaarschnitt 45min)
 * 2. User optionally selects employee (default: "any available")
 * 3. Calendar shows slots where service duration fits
 * 4. User selects slot and confirms
 *
 * @property int $companyId Company context
 * @property string $selectedServiceId Currently selected service UUID
 * @property int $serviceDuration Duration of selected service in minutes
 * @property string $employeePreference "any" or employee UUID
 * @property int $weekOffset Week navigation offset
 * @property array $weekData Available slots for current week
 * @property array $weekMetadata Week display information
 * @property string|null $selectedSlot Selected slot datetime
 */
class AppointmentBookingFlow extends Component
{
    // Required: Company context
    public int $companyId;

    // Service selection
    public ?string $selectedServiceId = null;
    public int $serviceDuration = 45; // Default: Damenhaarschnitt
    public ?string $serviceName = null;

    // Employee preference
    public string $employeePreference = 'any'; // 'any' or employee UUID

    // Week navigation
    public int $weekOffset = 0;

    // Week data
    public array $weekData = [];
    public array $weekMetadata = [];

    // Selected slot
    public ?string $selectedSlot = null;
    public ?string $selectedSlotLabel = null;

    // UI state
    public bool $loading = false;
    public ?string $error = null;

    // Available services and employees
    public array $availableServices = [];
    public array $availableEmployees = [];

    /**
     * Component initialization
     *
     * @param int $companyId Company context
     * @param string|null $preselectedServiceId Pre-selected service (optional)
     * @param string|null $preselectedSlot Pre-selected slot (optional, for edit mode)
     */
    public function mount(
        int $companyId,
        ?string $preselectedServiceId = null,
        ?string $preselectedSlot = null
    ): void {
        $this->companyId = $companyId;
        $this->selectedSlot = $preselectedSlot;

        // Load available services and employees
        $this->loadAvailableServices();
        $this->loadAvailableEmployees();

        // Set default service (Damenhaarschnitt) or preselected
        if ($preselectedServiceId) {
            $this->selectedServiceId = $preselectedServiceId;
            $this->loadServiceInfo();
        } else {
            $this->setDefaultService();
        }

        // Load initial week data
        $this->loadWeekData();

        Log::debug('[AppointmentBookingFlow] Component mounted', [
            'company_id' => $this->companyId,
            'selected_service' => $this->selectedServiceId,
            'service_duration' => $this->serviceDuration,
            'employee_preference' => $this->employeePreference,
        ]);
    }

    /**
     * Load available services for company
     */
    protected function loadAvailableServices(): void
    {
        $this->availableServices = Service::where('company_id', $this->companyId)
            ->where('is_active', true)
            ->orderBy('priority', 'asc')
            ->orderBy('name', 'asc')
            ->get(['id', 'name', 'duration_minutes'])
            ->toArray();

        Log::debug('[AppointmentBookingFlow] Loaded services', [
            'count' => count($this->availableServices),
        ]);
    }

    /**
     * Load available employees for company
     */
    protected function loadAvailableEmployees(): void
    {
        $this->availableEmployees = Staff::where('company_id', $this->companyId)
            ->where('is_active', true)
            ->orderBy('name', 'asc')
            ->get(['id', 'name', 'email'])
            ->toArray();

        Log::debug('[AppointmentBookingFlow] Loaded employees', [
            'count' => count($this->availableEmployees),
        ]);
    }

    /**
     * Set default service (Damenhaarschnitt or first available)
     */
    protected function setDefaultService(): void
    {
        // Try to find "Damenhaarschnitt"
        $default = collect($this->availableServices)->first(function ($service) {
            return str_contains(strtolower($service['name']), 'damenhaarschnitt');
        });

        // Fallback to first service
        if (!$default && count($this->availableServices) > 0) {
            $default = $this->availableServices[0];
        }

        if ($default) {
            $this->selectedServiceId = $default['id'];
            $this->serviceName = $default['name'];
            $this->serviceDuration = $default['duration_minutes'];

            Log::info('[AppointmentBookingFlow] Default service set', [
                'service_id' => $this->selectedServiceId,
                'name' => $this->serviceName,
                'duration' => $this->serviceDuration,
            ]);
        }
    }

    /**
     * Load service information
     */
    protected function loadServiceInfo(): void
    {
        try {
            $service = Service::findOrFail($this->selectedServiceId);
            $this->serviceName = $service->name;
            $this->serviceDuration = $service->duration_minutes;

        } catch (\Exception $e) {
            $this->error = "Service nicht gefunden.";
            Log::error('[AppointmentBookingFlow] Service not found', [
                'service_id' => $this->selectedServiceId,
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * User selects a service
     * Triggers: Reload calendar with new duration
     *
     * @param string $serviceId Service UUID
     */
    public function selectService(string $serviceId): void
    {
        $this->selectedServiceId = $serviceId;
        $this->selectedSlot = null; // Reset slot selection
        $this->selectedSlotLabel = null;

        // Load service info
        $this->loadServiceInfo();

        // Reload week data with new duration
        $this->loadWeekData();

        Log::info('[AppointmentBookingFlow] Service selected', [
            'service_id' => $serviceId,
            'name' => $this->serviceName,
            'duration' => $this->serviceDuration,
        ]);

        $this->dispatch('notify', [
            'message' => "Service gewählt: {$this->serviceName} ({$this->serviceDuration} Min)",
            'type' => 'info',
        ]);
    }

    /**
     * User selects employee preference
     * Triggers: Reload calendar for specific employee
     *
     * @param string $preference "any" or employee UUID
     */
    public function selectEmployee(string $preference): void
    {
        $this->employeePreference = $preference;
        $this->selectedSlot = null; // Reset slot selection
        $this->selectedSlotLabel = null;

        // Reload week data for employee
        $this->loadWeekData();

        $employeeName = $preference === 'any'
            ? 'Nächster verfügbarer'
            : collect($this->availableEmployees)->firstWhere('id', $preference)['name'] ?? 'Unbekannt';

        Log::info('[AppointmentBookingFlow] Employee preference selected', [
            'preference' => $preference,
            'name' => $employeeName,
        ]);

        $this->dispatch('notify', [
            'message' => "Mitarbeiter: {$employeeName}",
            'type' => 'info',
        ]);
    }

    /**
     * Load week data from Cal.com API
     * Duration-aware: Only shows slots where service duration fits
     */
    public function loadWeekData(): void
    {
        if (!$this->selectedServiceId) {
            Log::warning('[AppointmentBookingFlow] Cannot load week data without service');
            return;
        }

        $this->loading = true;
        $this->error = null;

        try {
            // Calculate week start
            $weekStart = now()->addWeeks($this->weekOffset)->startOfWeek(Carbon::MONDAY);

            // Cache key includes service duration and employee
            $cacheKey = sprintf(
                'appointment_flow:%s:%s:%d:%s',
                $this->companyId,
                $this->selectedServiceId,
                $this->weekOffset,
                $this->employeePreference
            );

            // Try cache first (60 seconds)
            $this->weekData = Cache::remember($cacheKey, 60, function () use ($weekStart) {
                $availabilityService = app(WeeklyAvailabilityService::class);

                // Get availability with duration awareness
                // TODO: WeeklyAvailabilityService needs to accept duration and employee params
                // For now, we'll use the existing method and filter client-side
                return $availabilityService->getWeekAvailability(
                    $this->selectedServiceId,
                    $weekStart
                );
            });

            $this->weekMetadata = app(WeeklyAvailabilityService::class)->getWeekMetadata($weekStart);

            $totalSlots = array_sum(array_map('count', $this->weekData));

            Log::info('[AppointmentBookingFlow] Week data loaded', [
                'service_id' => $this->selectedServiceId,
                'duration' => $this->serviceDuration,
                'employee' => $this->employeePreference,
                'week_offset' => $this->weekOffset,
                'total_slots' => $totalSlots,
            ]);

        } catch (CalcomApiException $e) {
            $this->error = "Cal.com API-Fehler: {$e->getMessage()}";
            $this->weekData = $this->getEmptyWeekStructure();

            Log::error('[AppointmentBookingFlow] Cal.com error', [
                'error' => $e->getMessage(),
                'status_code' => $e->getStatusCode(),
            ]);

        } catch (\Exception $e) {
            $this->error = "Fehler beim Laden: {$e->getMessage()}";
            $this->weekData = $this->getEmptyWeekStructure();

            Log::error('[AppointmentBookingFlow] Load error', [
                'error' => $e->getMessage(),
            ]);

        } finally {
            $this->loading = false;
        }
    }

    /**
     * User selects a time slot
     *
     * @param string $datetime ISO 8601 datetime
     * @param string $label Human-readable label
     */
    public function selectSlot(string $datetime, string $label): void
    {
        $this->selectedSlot = $datetime;
        $this->selectedSlotLabel = $label;

        Log::info('[AppointmentBookingFlow] Slot selected', [
            'datetime' => $datetime,
            'label' => $label,
            'service' => $this->serviceName,
            'duration' => $this->serviceDuration,
        ]);

        // Dispatch browser event for parent form
        $this->js("
            window.dispatchEvent(new CustomEvent('slot-selected', {
                detail: {
                    datetime: '{$datetime}',
                    serviceId: '{$this->selectedServiceId}',
                    serviceDuration: {$this->serviceDuration},
                    employee: '{$this->employeePreference}'
                }
            }));
        ");

        $this->dispatch('notify', [
            'message' => "Termin gewählt: {$label}",
            'type' => 'success',
        ]);
    }

    /**
     * Navigate to previous week
     */
    public function previousWeek(): void
    {
        $this->weekOffset--;
        $this->selectedSlot = null;
        $this->loadWeekData();
    }

    /**
     * Navigate to next week
     */
    public function nextWeek(): void
    {
        $this->weekOffset++;
        $this->selectedSlot = null;
        $this->loadWeekData();
    }

    /**
     * Jump to current week
     */
    public function goToCurrentWeek(): void
    {
        $this->weekOffset = 0;
        $this->selectedSlot = null;
        $this->loadWeekData();
    }

    /**
     * Get empty week structure
     */
    protected function getEmptyWeekStructure(): array
    {
        return [
            'monday' => [],
            'tuesday' => [],
            'wednesday' => [],
            'thursday' => [],
            'friday' => [],
            'saturday' => [],
            'sunday' => [],
        ];
    }

    /**
     * Get day label for display
     */
    public function getDayLabel(string $dayKey): string
    {
        return match($dayKey) {
            'monday' => 'Mo',
            'tuesday' => 'Di',
            'wednesday' => 'Mi',
            'thursday' => 'Do',
            'friday' => 'Fr',
            'saturday' => 'Sa',
            'sunday' => 'So',
            default => '?',
        };
    }

    /**
     * Check if slot is selected
     */
    public function isSlotSelected(string $datetime): bool
    {
        return $this->selectedSlot === $datetime;
    }

    /**
     * Get total slots count
     */
    public function getTotalSlotsProperty(): int
    {
        return array_sum(array_map('count', $this->weekData));
    }

    /**
     * Render component
     */
    public function render()
    {
        return view('livewire.appointment-booking-flow');
    }
}
