<?php

namespace App\Filament\Admin\Pages;

use App\Models\Company;
use App\Services\CalcomV2Service;
use App\Services\RetellV2Service;
use Filament\Pages\Page;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Livewire\Attributes\Computed;
use Livewire\Attributes\On;
use Livewire\WithFileUploads;

class RetellUltimateControlCenter extends Page
{
    use WithFileUploads;

    public static function shouldRegisterNavigation(): bool
    {
        return true; // Temporarily allow all admins
        // return auth()->user()?->can('manage_retell_control_center') ?? false;
    }

    public static function canAccess(): bool
    {
        return true; // Temporarily allow all admins
        // return auth()->user()?->can('manage_retell_control_center') ?? false;
    }

    protected static ?string $navigationIcon = 'heroicon-o-command-line';

    protected static ?string $navigationGroup = 'Einrichtung';

    protected static ?string $navigationLabel = 'Retell Konfiguration';

    protected static ?int $navigationSort = 50;

    protected static string $view = 'filament.admin.pages.retell-ultimate-control-center';

    public function getHeading(): string
    {
        return ''; // Keine doppelte Überschrift
    }

    // Component Properties
    public array $agents = [];

    public array $functions = [];

    public array $agentFunctions = [];

    public array $groupedAgents = [];

    public array $webhooks = [];

    public array $phoneNumbers = [];

    public ?array $selectedAgent = null;

    public ?array $selectedFunction = null;

    public ?array $llmData = null;

    public ?string $selectedAgentId = null;

    // UI State
    public string $activeTab = 'dashboard';

    public bool $aiAssistantEnabled = true;

    public array $realtimeMetrics = [
        'active_calls' => 0,
        'queued_calls' => 0,
        'success_rate' => 0,
        'avg_wait_time' => 0,
        'agent_utilization' => 0,
        'total_calls_today' => 0,
        'total_bookings_today' => 0,
        'failed_calls' => 0,
    ];

    // Service configuration - store only serializable data
    public ?string $retellApiKey = null;

    public ?int $companyId = null;

    // Error handling
    public ?string $error = null;

    public ?string $successMessage = null;

    // Loading state
    public bool $isLoading = true;

    // Function Builder State
    public bool $showFunctionBuilder = false;

    public array $functionTemplates = [];

    public array $editingFunction = [];

    // Modal states
    public bool $showAgentEditor = false;

    public bool $showPerformanceDashboard = false;

    public array $editingAgent = [];

    public ?array $performanceAgent = null;

    public array $performanceMetrics = [];

    public string $performancePeriod = '7d';

    // Search & Filter
    public string $agentSearch = '';

    public string $functionSearch = '';

    public string $functionSearchTerm = '';

    public string $functionTypeFilter = '';

    public array $activeFilters = [];

    // Dashboard filters
    public string $dashboardFilter = 'all'; // all, phone, agent

    public ?string $selectedPhoneFilter = null;

    public ?string $selectedAgentFilter = null;

    // Global state for consistent agent selection across tabs
    public array $globalState = [
        'selectedAgentId' => null,
        'selectedVersion' => null,
        'selectedBaseName' => null,
    ];

    // Phone agent assignments
    public array $phoneAgentAssignment = [];

    // File upload
    public $agentImportFile;

    // Settings
    public array $defaultSettings = [
        'voice_id' => 'openai-Alloy',
        'language' => 'de-DE',
        'interruption_sensitivity' => 1,
        'response_speed' => 1.0,
    ];

    // Webhooks
    public array $webhookLogs = [];

    public array $webhookStats = [
        'total' => 0,
        'success' => 0,
        'failed' => 0,
        'avg_response_time' => 0,
    ];

    public ?array $webhookTestResult = null;

    // Call History
    public array $calls = [];

    public string $callsFilter = 'all'; // all, today, week, month

    public string $callsSearch = '';

    public ?array $selectedCall = null;

    public bool $showCallDetails = false;

    public string $callsPeriod = '24h'; // 1h, 24h, 7d, 30d, all

    // Version management
    public string $newVersionName = '';

    public function mount(): void
    {
        // Authorization check - temporarily disabled
        // if (!auth()->user()->can('manage_retell_control_center')) {
        //     abort(403, 'Unauthorized');
        // }

        try {
            Log::info('Control Center - mount() called');

            // Initialize all arrays to ensure they're not null
            $this->agents = [];
            $this->functions = [];
            $this->agentFunctions = [];
            $this->groupedAgents = [];
            $this->webhooks = [];
            $this->phoneNumbers = [];
            $this->phoneAgentAssignment = [];
            $this->functionTemplates = [];
            
            // Initialize editor properties
            $this->editingAgent = [];
            $this->editingAgentFull = [];
            $this->editingLLM = [];
            $this->editingFunctions = [];
            $this->editingPostCallAnalysis = [];
            $this->editingWebhookSettings = [];
            $this->originalAgentData = [];
            $this->agentVersions = [];
            
            // Ensure editor states are initialized
            $this->showAgentEditor = false;
            $this->showFullEditor = false;
            $this->editorActiveTab = 'basic';

            $this->initializeServices();
            $this->loadFunctionTemplates();
            $this->loadDefaultSettings();

            // Load initial data directly in mount
            $this->loadInitialData();

            Log::info('Control Center - mount() completed successfully');
        } catch (\Exception $e) {
            Log::error('Control Center - mount() error: ' . $e->getMessage(), [
                'trace' => $e->getTraceAsString(),
            ]);

            throw $e;
        }
    }

    protected function initializeServices(): void
    {
        try {
            $user = auth()->user();
            Log::info('Control Center Init - User check', ['user_id' => $user?->id, 'company_id' => $user?->company_id]);

            if (! $user || ! $user->company_id) {
                $this->error = 'No company found for user';
                Log::warning('Control Center Init - No company found for user', [
                    'auth_check' => auth()->check(),
                    'user' => $user ? $user->toArray() : null,
                ]);

                return;
            }

            // Store company ID for persistence
            $this->companyId = $user->company_id;

            $company = Company::find($this->companyId);
            if (! $company) {
                $this->error = 'Company not found for ID: ' . $this->companyId;
                Log::warning('Control Center Init - Company not found', ['company_id' => $this->companyId]);

                return;
            }

            Log::info('Control Center Init - Company found', [
                'company_id' => $company->id,
                'has_retell_key' => ! empty($company->retell_api_key),
                'key_length' => strlen($company->retell_api_key ?? ''),
                'key_prefix' => ! empty($company->retell_api_key) ? substr($company->retell_api_key, 0, 8) . '...' : null,
            ]);

            // Store API key for later use
            if ($company->retell_api_key) {
                $apiKey = $company->retell_api_key;

                try {
                    if (strlen($apiKey) > 50) {
                        // Try to decrypt
                        try {
                            $apiKey = decrypt($apiKey);
                        } catch (\Exception $decryptError) {
                            // If decryption fails, try using the key as-is
                            // This handles cases where the key might not be encrypted
                            Log::warning('Using API key as-is, decryption failed', ['error' => $decryptError->getMessage()]);
                        }
                    }
                    $this->retellApiKey = $apiKey;
                    Log::info('Control Center Init - Retell API key stored successfully');
                } catch (\Exception $e) {
                    $this->error = 'Failed to process API key: ' . $e->getMessage();
                    Log::error('Control Center Init - Failed to process API key', ['error' => $e->getMessage()]);
                }
            } else {
                Log::warning('Control Center Init - No Retell API key found');
            }
        } catch (\Exception $e) {
            $this->error = 'Failed to initialize services: ' . $e->getMessage();
            Log::error('Control Center initialization failed', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
        }
    }

    /**
     * Get Retell service instance.
     */
    protected function getRetellService(): ?RetellV2Service
    {
        // Try to get API key from property first
        $apiKey = $this->retellApiKey;

        // If not available, try to get from company
        if (! $apiKey && $this->companyId) {
            $company = Company::find($this->companyId);
            if ($company && $company->retell_api_key) {
                $apiKey = $company->retell_api_key;
                if (strlen($apiKey) > 50) {
                    try {
                        $apiKey = decrypt($apiKey);
                    } catch (\Exception $e) {
                        // Use as-is if decryption fails
                    }
                }
                $this->retellApiKey = $apiKey;
            }
        }

        if (! $apiKey) {
            return null;
        }

        return new RetellV2Service($apiKey);
    }

    /**
     * Get CalCom service instance.
     */
    protected function getCalcomService(): ?CalcomV2Service
    {
        if (! $this->companyId) {
            return null;
        }

        $company = Company::find($this->companyId);
        if (! $company || ! $company->calcom_api_key) {
            return null;
        }

        return new CalcomV2Service($company);
    }

    public function initialize(): void
    {
        $this->loadInitialData();
    }

    public function loadInitialData(): void
    {
        $this->isLoading = true;

        try {
            // Re-initialize services in case auth wasn't ready during mount
            if (! $this->retellApiKey) {
                $this->initializeServices();
            }

            $retellService = $this->getRetellService();

            Log::info('Control Center - loadInitialData called', [
                'has_retell_key' => ! empty($this->retellApiKey),
                'has_retell_service' => $retellService !== null,
                'called_from' => debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2)[1]['function'] ?? 'unknown',
            ]);

            if (! $retellService) {
                Log::warning('Control Center - loadInitialData skipped - no retell service', [
                    'api_key_set' => ! empty($this->retellApiKey),
                ]);
                $this->error = 'Retell API key not configured. Please add your API key in Company settings.';
                // Set empty defaults
                $this->agents = [];
                $this->phoneNumbers = [];
                $this->groupedAgents = [];
                $this->isLoading = false;

                // Show helpful message instead of empty state
                $this->successMessage = 'To get started, please add your Retell API key in Company settings.';

                return;
            }

            // Load agents
            $this->loadAgents();

            // Load phone numbers
            $this->loadPhoneNumbers();

            // Load metrics
            $this->loadMetrics();

            // Load webhook logs
            $this->loadWebhookLogs();

            // Initialize phone assignments with sanitized keys
            foreach ($this->phoneNumbers as $phone) {
                $sanitizedKey = str_replace(['+', '-', ' ', '(', ')'], '', $phone['phone_number']);
                $this->phoneAgentAssignment[$sanitizedKey] = $phone['agent_id'] ?? '';
            }

            // Clear any previous errors
            $this->error = null;

            // Dispatch loaded event
            $this->dispatch('control-center-mounted');

            Log::info('Control Center - Data loaded successfully', [
                'agents_count' => count($this->agents),
                'phones_count' => count($this->phoneNumbers),
                'metrics' => $this->realtimeMetrics,
            ]);
        } catch (\Exception $e) {
            Log::error('Control Center - loadInitialData error', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            $this->error = 'Failed to load data: ' . $e->getMessage();
        } finally {
            $this->isLoading = false;
            // Force UI update
            $this->dispatch('$refresh');
        }
    }

    public function loadAgents(): void
    {
        try {
            // Initialize retellService variable to avoid undefined errors
            $retellService = null;

            // First try to load from local database
            // Use withoutGlobalScopes to avoid tenant scope issues in Livewire context
            $localAgents = \App\Models\RetellAgent::withoutGlobalScopes()
                ->where('company_id', $this->companyId)
                ->get();

            if ($localAgents->isNotEmpty()) {
                Log::info('Control Center - Loading agents from local database', [
                    'count' => $localAgents->count(),
                ]);

                // Map local agents to expected format
                $agentData = $localAgents->map(function ($agent) {
                    $config = $agent->configuration ?? [];
                    
                    // Load relationships
                    $agent->load(['phoneNumber.branch']);
                    
                    // Since we now store raw API data, merge config directly
                    $agentArray = array_merge($config, [
                        'agent_id' => $agent->agent_id,
                        'agent_name' => $agent->name,
                        'display_name' => $this->parseAgentName($agent->name),
                        // Use database version fields instead of extracting from name
                        'version' => $agent->version ?? $config['version'] ?? null,
                        'version_title' => $agent->version_title ?? $config['version_title'] ?? null,
                        'is_published' => $agent->is_published ?? $config['is_published'] ?? false,
                        'base_name' => $this->parseAgentName($agent->name),
                        'is_active' => $agent->is_active,
                        'status' => $agent->is_active ? 'active' : 'inactive',
                        'metrics' => $this->getAgentMetrics($agent->agent_id),
                        'function_count' => $agent->getFunctionCount(),
                        'last_synced_at' => $agent->last_synced_at?->toIso8601String(),
                        'sync_status' => $agent->sync_status,
                        'needs_sync' => $agent->needsSync(),
                        'configuration' => $config, // Keep full config for editing
                        // Include relationship data
                        'phone_number' => $agent->phoneNumber ? $agent->phoneNumber->number : null,
                        'phone_number_id' => $agent->phone_number_id,
                        'branch_name' => $agent->phoneNumber && $agent->phoneNumber->branch ? $agent->phoneNumber->branch->name : null,
                        'branch_id' => $agent->phoneNumber ? $agent->phoneNumber->branch_id : null,
                    ]);
                    
                    return $agentArray;
                })->toArray();

                $result = ['agents' => $agentData];
            } else {
                // Fallback to API if no local data
                $retellService = $this->getRetellService();
                Log::info('Control Center - No local agents, falling back to API', [
                    'has_retell_service' => $retellService !== null,
                ]);

                if (! $retellService) {
                    Log::warning('Control Center - loadAgents - no retell service, checking cache');

                    // Try to load from cache before giving up
                    $cachedAgents = Cache::get("company_{$this->companyId}_agents", []);
                    if (! empty($cachedAgents)) {
                        $this->agents = $cachedAgents;
                        $this->error = 'Retell service not configured. Showing cached data.';
                        $this->processAgentGroups($cachedAgents);

                        return;
                    }

                    $this->agents = [];
                    $this->groupedAgents = [];
                    $this->error = 'No Retell API key configured. Please add it in company settings.';

                    return;
                }

                try {
                    $result = Cache::remember('retell_agents_' . auth()->id(), 60, function () use ($retellService) {
                        Log::info('Control Center - Fetching agents from API');

                        return $retellService->listAgents();
                    });

                    // Cache successful result for company-wide fallback
                    if (! empty($result['agents'])) {
                        Cache::put("company_{$this->companyId}_agents", $result['agents'], 3600);
                    }
                } catch (\Exception $apiError) {
                    Log::error('Failed to fetch agents from API', [
                        'error' => $apiError->getMessage(),
                        'company_id' => $this->companyId,
                    ]);

                    // Try cache fallback
                    $cachedAgents = Cache::get("company_{$this->companyId}_agents", []);
                    if (! empty($cachedAgents)) {
                        $result = ['agents' => $cachedAgents];
                        $this->error = 'Unable to connect to Retell API. Showing cached data.';
                    } else {
                        $result = ['agents' => []];
                        $this->error = 'Unable to load agents. Please check your internet connection.';
                    }
                }
            }

            Log::info('Control Center - Agents loaded', [
                'count' => count($result['agents'] ?? []),
            ]);

            // Group agents by base name (without version)
            $agentGroups = collect($result['agents'] ?? [])
                ->map(function ($agent) use ($retellService) {
                    $agent['display_name'] = $this->parseAgentName($agent['agent_name'] ?? '');
                    $agent['version'] = $this->extractVersion($agent['agent_name'] ?? '');
                    $agent['base_name'] = $this->getBaseName($agent['agent_name'] ?? '');
                    $agent['is_active'] = ($agent['status'] ?? 'inactive') === 'active';
                    $agent['metrics'] = $this->getAgentMetrics($agent['agent_id']);

                    // Get function count for this agent
                    $agent['function_count'] = 0;

                    // If function_count is already set (from local DB), use it
                    if (isset($agent['function_count']) && is_numeric($agent['function_count'])) {
                        // Already have the count from local data
                    } elseif ($retellService &&
                        isset($agent['response_engine']) && 
                        is_array($agent['response_engine']) &&
                        isset($agent['response_engine']['type']) &&
                        $agent['response_engine']['type'] === 'retell-llm' &&
                        isset($agent['response_engine']['llm_id'])) {
                        // Only try to fetch from API if we have a retell service
                        try {
                            $llmData = Cache::remember(
                                "retell_llm_functions_{$agent['response_engine']['llm_id']}",
                                300,
                                fn () => $retellService->getRetellLLM($agent['response_engine']['llm_id'])
                            );
                            $agent['function_count'] = count($llmData['general_tools'] ?? []);
                        } catch (\Exception $e) {
                            // Silently fail, just keep count as 0
                            Log::debug('Failed to get function count for agent', [
                                'agent_id' => $agent['agent_id'],
                                'error' => $e->getMessage(),
                            ]);
                        }
                    }

                    return $agent;
                })
                ->groupBy('base_name');

            // Store grouped agents for dropdown
            $this->groupedAgents = [];

            // Get only the main agent with active version for each group
            $this->agents = [];
            foreach ($agentGroups as $baseName => $versions) {
                // Sort versions to get the active one first, then by version number
                $sortedVersions = $versions->sortByDesc(function ($agent) {
                    $score = $agent['is_active'] ? 1000 : 0;
                    $versionNum = (float) str_replace('V', '', $agent['version'] ?? 'V1');

                    return $score + $versionNum;
                });

                // Get the main (active or latest) version
                $mainAgent = $sortedVersions->first();
                $mainAgent['total_versions'] = $versions->count();
                $mainAgent['active_version'] = $sortedVersions->firstWhere('is_active');

                $this->agents[] = $mainAgent;

                // Store grouped data with all version details
                $this->groupedAgents[$baseName] = [
                    'base_name' => $baseName,
                    'versions' => $sortedVersions->map(function ($v) {
                        return [
                            'agent_id' => $v['agent_id'],
                            'version' => $v['version'] ?? 'V1',
                            'is_active' => $v['is_active'] ?? false,
                            'agent_name' => $v['agent_name'] ?? '',
                            'display_name' => $v['display_name'] ?? $v['agent_name'] ?? '',
                        ];
                    })->values()->toArray(),
                ];
            }
        } catch (\Exception $e) {
            $this->error = 'Failed to load agents: ' . $e->getMessage();
            $this->agents = [];
            $this->groupedAgents = [];
        }
    }

    public function loadPhoneNumbers(): void
    {
        try {
            $retellService = $this->getRetellService();
            if (! $retellService) {
                Log::warning('loadPhoneNumbers - No Retell service');
                $this->phoneNumbers = [];

                return;
            }

            Log::info('Loading phone numbers from Retell API');
            $result = $retellService->listPhoneNumbers();

            Log::info('Phone numbers loaded', [
                'count' => count($result['phone_numbers'] ?? []),
                'data' => $result['phone_numbers'] ?? [],
            ]);

            // Create agent lookup map for O(1) access
            $agentMap = collect($this->agents)->keyBy('agent_id')->toArray();

            // Enhance phone numbers with agent information
            $this->phoneNumbers = collect($result['phone_numbers'] ?? [])
                ->map(function ($phone) use ($agentMap) {
                    // Normalize the agent_id field (Retell uses inbound_agent_id)
                    if (isset($phone['inbound_agent_id']) && ! isset($phone['agent_id'])) {
                        $phone['agent_id'] = $phone['inbound_agent_id'];
                    }

                    // Find the associated agent using map lookup (O(1) instead of O(n))
                    if (isset($phone['agent_id']) && ! empty($phone['agent_id']) && isset($agentMap[$phone['agent_id']])) {
                        $agent = $agentMap[$phone['agent_id']];
                        $phone['agent_name'] = $agent['display_name'] ?? 'Unknown';
                        $phone['agent_version'] = $agent['version'] ?? 'V1';
                        $phone['agent_is_active'] = $agent['is_active'] ?? false;
                    }

                    return $phone;
                })
                ->toArray();
        } catch (\Exception $e) {
            Log::error('Failed to load phone numbers', ['error' => $e->getMessage()]);
            $this->phoneNumbers = [];
        }
    }

    public function loadMetrics(): void
    {
        try {
            // Build cache key based on filters
            $cacheKey = 'control_center_metrics';
            if ($this->dashboardFilter === 'phone' && $this->selectedPhoneFilter) {
                $cacheKey .= '_phone_' . md5($this->selectedPhoneFilter);
            } elseif ($this->dashboardFilter === 'agent' && $this->selectedAgentFilter) {
                $cacheKey .= '_agent_' . $this->selectedAgentFilter;
            }

            // Fetch real data from database
            $this->realtimeMetrics = Cache::remember($cacheKey, 30, function () {
                // Get real metrics from database
                $query = \App\Models\Call::query();

                // Apply company filter
                if ($this->companyId) {
                    $query->where('company_id', $this->companyId);
                }

                // Apply phone/agent filters if set
                if ($this->dashboardFilter === 'phone' && $this->selectedPhoneFilter) {
                    $query->where('to_number', $this->selectedPhoneFilter);
                } elseif ($this->dashboardFilter === 'agent' && $this->selectedAgentFilter) {
                    $query->where('retell_agent_id', $this->selectedAgentFilter);
                }

                // Calculate metrics
                $todayStart = now()->startOfDay();
                $todayEnd = now()->endOfDay();

                // Active calls (in_progress, active, ongoing)
                $activeCalls = (clone $query)->whereIn('call_status', ['in_progress', 'active', 'ongoing'])->count();

                // Queued calls (pending, queued)
                $queuedCalls = (clone $query)->whereIn('call_status', ['pending', 'queued'])->count();

                // Today's calls
                $todaysCallsQuery = (clone $query)->whereBetween('created_at', [$todayStart, $todayEnd]);
                $totalCallsToday = $todaysCallsQuery->count();

                // Success rate (calls that resulted in appointments)
                $successfulCalls = (clone $todaysCallsQuery)
                    ->whereIn('call_status', ['completed', 'analyzed'])
                    ->whereExists(function ($q) {
                        $q->select(\DB::raw(1))
                            ->from('appointments')
                            ->whereColumn('appointments.call_id', 'calls.id');
                    })
                    ->count();

                $successRate = $totalCallsToday > 0 ? round(($successfulCalls / $totalCallsToday) * 100, 1) : 0;

                // Average wait time (time from created to answered)
                $avgWaitTime = (clone $todaysCallsQuery)
                    ->whereNotNull('start_timestamp')
                    ->selectRaw('AVG(TIMESTAMPDIFF(SECOND, created_at, start_timestamp)) as avg_wait')
                    ->value('avg_wait') ?? 0;

                // Today's bookings
                $totalBookingsToday = \App\Models\Appointment::where('company_id', $this->companyId)
                    ->whereBetween('created_at', [$todayStart, $todayEnd])
                    ->where('source', 'phone')
                    ->count();

                // Failed calls
                $failedCalls = (clone $todaysCallsQuery)
                    ->whereIn('call_status', ['failed', 'error', 'abandoned'])
                    ->count();

                // Agent utilization (percentage of time on calls)
                $agentUtilization = $this->calculateAgentUtilization();

                return [
                    'active_calls' => $activeCalls,
                    'queued_calls' => $queuedCalls,
                    'success_rate' => $successRate,
                    'avg_wait_time' => round($avgWaitTime),
                    'agent_utilization' => $agentUtilization,
                    'total_calls_today' => $totalCallsToday,
                    'total_bookings_today' => $totalBookingsToday,
                    'failed_calls' => $failedCalls,
                ];
            });

            // Emit event for real-time updates
            $this->dispatch('metrics-updated', $this->realtimeMetrics);
        } catch (\Exception $e) {
            Log::error('Failed to load metrics', [
                'filter' => $this->dashboardFilter,
                'error' => $e->getMessage(),
            ]);

            // Set default values on error
            $this->realtimeMetrics = [
                'active_calls' => 0,
                'queued_calls' => 0,
                'success_rate' => 0,
                'avg_wait_time' => 0,
                'agent_utilization' => 0,
                'total_calls_today' => 0,
                'total_bookings_today' => 0,
                'failed_calls' => 0,
            ];
        }
    }

    public function selectAgent(string $agentId, ?string $source = null): void
    {
        try {
            // Find agent in our loaded agents
            $agent = collect($this->agents)->firstWhere('agent_id', $agentId);
            if (! $agent) {
                $this->error = 'Agent not found';

                return;
            }

            $this->selectedAgent = $agent;

            // Update global state
            $this->globalState['selectedAgentId'] = $agentId;
            $this->globalState['selectedVersion'] = $agent['version'] ?? null;
            $this->globalState['selectedBaseName'] = $agent['base_name'] ?? $agent['display_name'] ?? null;

            // Load LLM data if agent uses retell-llm
            if (isset($agent['response_engine']['type']) &&
                $agent['response_engine']['type'] === 'retell-llm' &&
                isset($agent['response_engine']['llm_id'])) {
                $this->loadLLMData($agent['response_engine']['llm_id']);
            }

            // Load full configuration from database
            $dbAgent = \App\Models\RetellAgent::where('agent_id', $agentId)->first();
            if ($dbAgent) {
                // configuration and settings are already cast to arrays in the model
                $config = is_array($dbAgent->configuration) ? $dbAgent->configuration : json_decode($dbAgent->configuration, true);
                $settings = is_array($dbAgent->settings) ? $dbAgent->settings : json_decode($dbAgent->settings, true);

                // Add configuration details to selected agent
                $this->selectedAgent['full_config'] = $config;
                $this->selectedAgent['settings'] = $settings;

                // Extract key configuration values
                $this->selectedAgent['voice_settings'] = [
                    'voice_id' => $config['voice_id'] ?? '',
                    'voice_model' => $config['voice_model'] ?? '',
                    'voice_temperature' => $config['voice_temperature'] ?? 0.2,
                    'voice_speed' => $config['voice_speed'] ?? 1.0,
                    'volume' => $config['volume'] ?? 1.0,
                ];

                // Extract LLM settings - check both possible paths
                $llmData = $config['retellLlmData'] ?? $config['llm_data'] ?? $config['response_engine'] ?? [];
                $this->selectedAgent['llm_settings'] = [
                    'model' => $llmData['model'] ?? $config['model'] ?? 'gpt-4',
                    'model_temperature' => $llmData['model_temperature'] ?? $config['model_temperature'] ?? 0.7,
                    'model_high_priority' => $llmData['model_high_priority'] ?? $config['model_high_priority'] ?? false,
                    'general_prompt' => $llmData['general_prompt'] ?? $config['general_prompt'] ?? '',
                ];

                $this->selectedAgent['conversation_settings'] = [
                    'language' => $config['language'] ?? 'en-US',
                    'enable_backchannel' => $config['enable_backchannel'] ?? true,
                    'backchannel_frequency' => $config['backchannel_frequency'] ?? 0.2,
                    'backchannel_words' => $config['backchannel_words'] ?? [],
                    'interruption_sensitivity' => $config['interruption_sensitivity'] ?? 0.5,
                    'responsiveness' => $config['responsiveness'] ?? 1,
                    'end_call_after_silence_ms' => $config['end_call_after_silence_ms'] ?? 30000,
                    'max_call_duration_ms' => $config['max_call_duration_ms'] ?? 300000,
                ];

                $this->selectedAgent['audio_settings'] = [
                    'ambient_sound_volume' => $config['ambient_sound_volume'] ?? 0,
                    'denoising_mode' => $config['denoising_mode'] ?? 'off',
                    'normalize_for_speech' => $config['normalize_for_speech'] ?? true,
                ];

                $this->selectedAgent['analysis_settings'] = [
                    'post_call_analysis_model' => $config['post_call_analysis_model'] ?? 'gpt-4',
                    'post_call_analysis_data' => $config['post_call_analysis_data'] ?? [],
                ];

                $this->selectedAgent['tools'] = $config['general_tools'] ?? [];
            }

            // Clear any previous errors
            $this->error = null;
        } catch (\Exception $e) {
            $this->error = 'Error selecting agent: ' . $e->getMessage();
        }
    }

    public function viewAgentFunctions(string $agentId): void
    {
        try {
            // Select the agent
            $this->selectAgent($agentId);

            if ($this->selectedAgent) {
                // Load the agent's functions
                $this->selectedAgentId = $agentId;
                $this->loadAgentFunctions();

                // Show a modal or expand the agent card to display functions
                $this->showFunctionBuilder = true;
                $this->successMessage = 'Loaded ' . count($this->agentFunctions) . ' functions for ' . ($this->selectedAgent['display_name'] ?? 'agent');
            }
        } catch (\Exception $e) {
            $this->error = 'Failed to load agent functions: ' . $e->getMessage();
        }
    }

    protected function loadLLMData(string $llmId): void
    {
        try {
            $retellService = $this->getRetellService();
            if (! $retellService) {
                $this->llmData = null;
                $this->functions = [];

                return;
            }

            $this->llmData = Cache::remember(
                "retell_llm_data_{$llmId}",
                300, // Cache for 5 minutes
                fn () => $retellService->getRetellLLM($llmId)
            );

            // Parse functions from LLM data
            if (isset($this->llmData['general_tools'])) {
                $this->functions = $this->llmData['general_tools'];
            }
        } catch (\Exception $e) {
            Log::error('Failed to load LLM data', [
                'llm_id' => $llmId,
                'error' => $e->getMessage(),
            ]);
            $this->llmData = null;
            $this->functions = [];
        }
    }

    protected function loadAgentFunctions(): void
    {
        if (! $this->selectedAgent || ! isset($this->selectedAgent['response_engine']['llm_id'])) {
            $this->functions = [];
            $this->agentFunctions = [];

            return;
        }

        try {
            $llmId = $this->selectedAgent['response_engine']['llm_id'];
            $retellService = $this->getRetellService();
            if (! $retellService) {
                $this->functions = [];
                $this->agentFunctions = [];

                return;
            }

            $llmData = Cache::remember(
                "retell_llm_functions_{$llmId}",
                300,
                fn () => $retellService->getRetellLLM($llmId)
            );

            $this->functions = $llmData['general_tools'] ?? [];

            // Process functions for display
            $this->agentFunctions = collect($this->functions)
                ->map(function ($function) {
                    // Add type categorization
                    if (str_contains($function['name'] ?? '', 'cal') || str_contains($function['url'] ?? '', 'cal')) {
                        $function['type'] = 'cal_com';
                    } elseif (str_contains($function['name'] ?? '', 'database') || str_contains($function['url'] ?? '', 'database')) {
                        $function['type'] = 'database';
                    } elseif (in_array($function['name'] ?? '', ['end_call', 'transfer_call'])) {
                        $function['type'] = 'system';
                    } else {
                        $function['type'] = 'custom';
                    }

                    return $function;
                })
                ->when(! empty($this->functionSearchTerm), function ($collection) {
                    return $collection->filter(function ($function) {
                        $searchTerm = strtolower($this->functionSearchTerm);

                        return str_contains(strtolower($function['name'] ?? ''), $searchTerm) ||
                               str_contains(strtolower($function['description'] ?? ''), $searchTerm);
                    });
                })
                ->when(! empty($this->functionTypeFilter), function ($collection) {
                    return $collection->where('type', $this->functionTypeFilter);
                })
                ->values()
                ->toArray();
        } catch (\Exception $e) {
            Log::error('Failed to load agent functions', ['error' => $e->getMessage()]);
            $this->functions = [];
            $this->agentFunctions = [];
        }
    }

    // Update functions when filters change
    public function updatedFunctionSearchTerm(): void
    {
        $this->loadAgentFunctions();
    }

    public function updatedFunctionTypeFilter(): void
    {
        $this->loadAgentFunctions();
    }

    protected function loadFunctionTemplates(): void
    {
        $this->functionTemplates = [
            'cal_com' => [
                [
                    'id' => 'check_availability',
                    'name' => 'Check Cal.com Availability',
                    'type' => 'check_availability_cal',
                    'icon' => 'calendar',
                    'category' => 'booking',
                    'description' => 'Check available time slots in Cal.com',
                    'config' => [
                        'url' => 'https://api.askproai.de/api/mcp/calcom/availability',
                        'method' => 'POST',
                        'speak_during_execution' => true,
                        'speak_during_execution_message' => 'Einen Moment, ich prüfe die Verfügbarkeit...',
                        'speak_after_execution' => true,
                        'speak_after_execution_message' => 'Ich habe die verfügbaren Termine gefunden.',
                        'parameters' => [
                            ['name' => 'date', 'type' => 'string', 'required' => true, 'description' => 'Datum im Format YYYY-MM-DD'],
                            ['name' => 'service', 'type' => 'string', 'required' => true, 'description' => 'Gewünschte Dienstleistung'],
                            ['name' => 'duration', 'type' => 'number', 'default' => 30, 'description' => 'Dauer in Minuten'],
                        ],
                    ],
                ],
                [
                    'id' => 'book_appointment',
                    'name' => 'Book Appointment',
                    'type' => 'book_appointment_cal',
                    'icon' => 'calendar-plus',
                    'category' => 'booking',
                    'description' => 'Create a booking in Cal.com',
                    'config' => [
                        'url' => 'https://api.askproai.de/api/mcp/calcom/booking',
                        'method' => 'POST',
                        'speak_during_execution' => true,
                        'speak_during_execution_message' => 'Ich buche jetzt Ihren Termin...',
                        'speak_after_execution' => true,
                        'speak_after_execution_message' => 'Ihr Termin wurde erfolgreich gebucht!',
                        'parameters' => [
                            ['name' => 'customer_name', 'type' => 'string', 'required' => true],
                            ['name' => 'customer_phone', 'type' => 'string', 'required' => true],
                            ['name' => 'customer_email', 'type' => 'string', 'required' => false],
                            ['name' => 'date', 'type' => 'string', 'required' => true],
                            ['name' => 'time', 'type' => 'string', 'required' => true],
                            ['name' => 'service', 'type' => 'string', 'required' => true],
                        ],
                    ],
                ],
            ],
            'database' => [
                [
                    'id' => 'query_customer',
                    'name' => 'Query Customer Database',
                    'type' => 'database_query',
                    'icon' => 'database',
                    'category' => 'data',
                    'description' => 'Look up customer information',
                    'config' => [
                        'url' => 'https://api.askproai.de/api/mcp/database/query',
                        'method' => 'POST',
                        'parameters' => [
                            ['name' => 'phone_number', 'type' => 'string', 'required' => true],
                            ['name' => 'fields', 'type' => 'array', 'default' => ['name', 'email', 'last_visit']],
                        ],
                    ],
                ],
            ],
            'system' => [
                [
                    'id' => 'end_call',
                    'name' => 'End Call',
                    'type' => 'end_call',
                    'icon' => 'phone-x',
                    'category' => 'system',
                    'description' => 'End the current call',
                    'config' => [
                        'built_in' => true,
                    ],
                ],
                [
                    'id' => 'transfer_call',
                    'name' => 'Transfer Call',
                    'type' => 'transfer_call',
                    'icon' => 'phone-forward',
                    'category' => 'system',
                    'description' => 'Transfer call to another number',
                    'config' => [
                        'built_in' => true,
                        'parameters' => [
                            ['name' => 'phone_number', 'type' => 'string', 'required' => true],
                        ],
                    ],
                ],
            ],
        ];
    }

    // UI Actions
    public function changeTab(string $tab): void
    {
        $this->activeTab = $tab;

        // Load initial data if not already loaded
        if (empty($this->agents) && empty($this->phoneNumbers)) {
            $this->loadInitialData();
        }

        // Refresh data based on tab
        match ($tab) {
            'dashboard' => $this->loadMetrics(),
            'agents' => $this->loadAgents(),
            'calls' => $this->loadCalls(),
            'phones' => $this->loadPhoneNumbers(),
            'metrics' => $this->loadMetrics(),
            'webhooks' => $this->loadWebhookLogs(),
            default => null
        };

        // Trigger UI update (Livewire v3 format)
        $this->dispatch('tab-changed', tab: $tab);
    }

    public function refreshData(): void
    {
        // Clear all caches
        Cache::forget('retell_agents_' . auth()->id());
        Cache::forget('control_center_metrics');

        // Reload everything
        $this->loadInitialData();

        $this->successMessage = 'Data refreshed successfully';
    }

    public function syncAgents(): void
    {
        try {
            $this->isLoading = true;
            $this->error = null;

            // Use MCP server to sync all agents
            $mcpServer = new \App\Services\MCP\RetellMCPServer;
            $result = $mcpServer->syncAllAgentData([
                'company_id' => $this->companyId,
                'force' => true,
            ]);

            if (isset($result['error'])) {
                $this->error = $result['error'];

                return;
            }

            if (isset($result['success']) && $result['success']) {
                $summary = $result['summary'] ?? [];
                $this->successMessage = sprintf(
                    'Sync completed: %d agents synced, %d errors, %d skipped',
                    $summary['synced'] ?? 0,
                    $summary['errors'] ?? 0,
                    $summary['skipped'] ?? 0
                );

                // Reload agents from local database
                $this->loadAgents();
            } else {
                $this->error = 'Sync failed. Please try again.';
            }
        } catch (\Exception $e) {
            $this->error = 'Error syncing agents: ' . $e->getMessage();
            Log::error('Agent sync failed', [
                'company_id' => $this->companyId,
                'error' => $e->getMessage(),
            ]);
        } finally {
            $this->isLoading = false;
        }
    }

    /**
     * Sync call data from Retell API.
     */
    public function syncCalls(string $period = '24h'): void
    {
        try {
            $this->isLoading = true;
            $this->error = null;

            $retellService = $this->getRetellService();
            if (! $retellService) {
                $this->error = 'Retell service not available';

                return;
            }

            // Calculate date range
            $endDate = now();
            $startDate = match ($period) {
                '1h' => now()->subHour(),
                '24h' => now()->subHours(24),
                '7d' => now()->subDays(7),
                '30d' => now()->subDays(30),
                'all' => null,
                default => now()->subHours(24)
            };

            Log::info('Syncing calls from Retell', [
                'period' => $period,
                'start_date' => $startDate?->toDateTimeString(),
                'end_date' => $endDate->toDateTimeString(),
            ]);

            // Get calls from Retell API (max 1000)
            $response = $retellService->listCalls(1000);

            if (empty($response['calls'])) {
                $this->successMessage = 'No calls found in the specified period';

                return;
            }

            $totalCalls = count($response['calls']);
            $syncedCount = 0;
            $skippedCount = 0;
            $errorCount = 0;

            foreach ($response['calls'] as $callData) {
                try {
                    // Check if call is within date range
                    if ($startDate && isset($callData['start_timestamp'])) {
                        $callTime = Carbon::createFromTimestampMs($callData['start_timestamp']);
                        if ($callTime->lt($startDate)) {
                            $skippedCount++;

                            continue;
                        }
                    }

                    // Check if call already exists
                    $exists = \App\Models\Call::where('call_id', $callData['call_id'])->exists();
                    if ($exists) {
                        $skippedCount++;

                        continue;
                    }

                    // Resolve phone number to branch
                    $phoneNumber = $callData['to_number'] ?? null;
                    $branch = null;

                    if ($phoneNumber) {
                        $branch = \App\Models\Branch::where('phone_number', $phoneNumber)
                            ->where('company_id', $this->companyId)
                            ->first();
                    }

                    // Create call record
                    \App\Models\Call::create([
                        'company_id' => $this->companyId,
                        'branch_id' => $branch?->id,
                        'call_id' => $callData['call_id'],
                        'phone_number' => $callData['from_number'] ?? null,
                        'to_number' => $callData['to_number'] ?? null,
                        'agent_id' => $callData['agent_id'] ?? null,
                        'start_timestamp' => isset($callData['start_timestamp'])
                            ? Carbon::createFromTimestampMs($callData['start_timestamp'])
                            : null,
                        'end_timestamp' => isset($callData['end_timestamp'])
                            ? Carbon::createFromTimestampMs($callData['end_timestamp'])
                            : null,
                        'duration' => $callData['call_length'] ?? 0,
                        'status' => $callData['call_status'] ?? 'unknown',
                        'disconnection_reason' => $callData['disconnection_reason'] ?? null,
                        'transcript' => $callData['transcript'] ?? null,
                        'transcript_summary' => $callData['summary'] ?? null,
                        'recording_url' => $callData['recording_url'] ?? null,
                        'metadata' => [
                            'call_type' => $callData['call_type'] ?? null,
                            'answered_by' => $callData['answered_by'] ?? null,
                            'dial_duration' => $callData['dial_duration'] ?? null,
                            'public_log_url' => $callData['public_log_url'] ?? null,
                        ],
                    ]);

                    $syncedCount++;
                } catch (\Exception $e) {
                    $errorCount++;
                    Log::error('Failed to sync call', [
                        'call_id' => $callData['call_id'] ?? 'unknown',
                        'error' => $e->getMessage(),
                    ]);
                }
            }

            // Clear metrics cache to force reload
            Cache::forget('control_center_metrics');

            $this->successMessage = sprintf(
                'Call sync completed: %d total, %d synced, %d skipped, %d errors',
                $totalCalls,
                $syncedCount,
                $skippedCount,
                $errorCount
            );

            // Reload metrics to show updated data
            $this->loadMetrics();
        } catch (\Exception $e) {
            $this->error = 'Failed to sync calls: ' . $e->getMessage();
            Log::error('Call sync failed', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
        } finally {
            $this->isLoading = false;
        }
    }

    /**
     * Import missing calls by comparing with Retell API.
     */
    public function importMissingCalls(): void
    {
        try {
            $this->isLoading = true;
            $this->error = null;

            $retellService = $this->getRetellService();
            if (! $retellService) {
                $this->error = 'Retell service not available';

                return;
            }

            // Get all call IDs from our database
            $existingCallIds = \App\Models\Call::where('company_id', $this->companyId)
                ->pluck('call_id')
                ->toArray();

            // Get calls from Retell API
            $response = $retellService->listCalls(1000);

            if (empty($response['calls'])) {
                $this->successMessage = 'No calls found in Retell';

                return;
            }

            $missingCalls = [];
            foreach ($response['calls'] as $call) {
                if (! in_array($call['call_id'], $existingCallIds)) {
                    $missingCalls[] = $call;
                }
            }

            if (empty($missingCalls)) {
                $this->successMessage = 'No missing calls found. Database is up to date.';

                return;
            }

            // Import missing calls
            $importedCount = 0;
            foreach ($missingCalls as $callData) {
                try {
                    // Same import logic as syncCalls
                    $phoneNumber = $callData['to_number'] ?? null;
                    $branch = null;

                    if ($phoneNumber) {
                        $branch = \App\Models\Branch::where('phone_number', $phoneNumber)
                            ->where('company_id', $this->companyId)
                            ->first();
                    }

                    \App\Models\Call::create([
                        'company_id' => $this->companyId,
                        'branch_id' => $branch?->id,
                        'call_id' => $callData['call_id'],
                        'phone_number' => $callData['from_number'] ?? null,
                        'to_number' => $callData['to_number'] ?? null,
                        'agent_id' => $callData['agent_id'] ?? null,
                        'start_timestamp' => isset($callData['start_timestamp'])
                            ? Carbon::createFromTimestampMs($callData['start_timestamp'])
                            : null,
                        'end_timestamp' => isset($callData['end_timestamp'])
                            ? Carbon::createFromTimestampMs($callData['end_timestamp'])
                            : null,
                        'duration' => $callData['call_length'] ?? 0,
                        'status' => $callData['call_status'] ?? 'unknown',
                        'disconnection_reason' => $callData['disconnection_reason'] ?? null,
                        'transcript' => $callData['transcript'] ?? null,
                        'transcript_summary' => $callData['summary'] ?? null,
                        'recording_url' => $callData['recording_url'] ?? null,
                        'metadata' => [
                            'call_type' => $callData['call_type'] ?? null,
                            'answered_by' => $callData['answered_by'] ?? null,
                            'dial_duration' => $callData['dial_duration'] ?? null,
                            'public_log_url' => $callData['public_log_url'] ?? null,
                        ],
                    ]);

                    $importedCount++;
                } catch (\Exception $e) {
                    Log::error('Failed to import missing call', [
                        'call_id' => $callData['call_id'] ?? 'unknown',
                        'error' => $e->getMessage(),
                    ]);
                }
            }

            $this->successMessage = sprintf(
                'Imported %d missing calls out of %d found',
                $importedCount,
                count($missingCalls)
            );

            // Reload metrics
            $this->loadMetrics();
        } catch (\Exception $e) {
            $this->error = 'Failed to import missing calls: ' . $e->getMessage();
            Log::error('Missing calls import failed', [
                'error' => $e->getMessage(),
            ]);
        } finally {
            $this->isLoading = false;
        }
    }

    /**
     * Load call history from database.
     */
    public function loadCalls(): void
    {
        try {
            $query = \App\Models\Call::where('company_id', $this->companyId)
                ->with(['branch', 'customer', 'appointments']);

            // Apply period filter
            $startDate = match ($this->callsPeriod) {
                '1h' => now()->subHour(),
                '24h' => now()->subHours(24),
                '7d' => now()->subDays(7),
                '30d' => now()->subDays(30),
                'all' => null,
                default => now()->subHours(24)
            };

            if ($startDate) {
                $query->where('start_timestamp', '>=', $startDate);
            }

            // Apply search filter
            if (! empty($this->callsSearch)) {
                $search = $this->callsSearch;
                $query->where(function ($q) use ($search) {
                    $q->where('phone_number', 'like', "%{$search}%")
                        ->orWhere('call_id', 'like', "%{$search}%")
                        ->orWhere('transcript_summary', 'like', "%{$search}%");
                });
            }

            // Apply status filter
            if ($this->callsFilter !== 'all') {
                switch ($this->callsFilter) {
                    case 'successful':
                        $query->where('status', 'completed')
                            ->where('disconnection_reason', '!=', 'customer_hung_up_early');

                        break;
                    case 'failed':
                        $query->whereIn('status', ['failed', 'error', 'abandoned']);

                        break;
                    case 'bookings':
                        $query->whereHas('appointments');

                        break;
                }
            }

            // Get calls with pagination
            $calls = $query->orderBy('start_timestamp', 'desc')
                ->limit(100)
                ->get();

            // Create agent lookup map for O(1) access
            $agentMap = collect($this->agents)->keyBy('agent_id')->toArray();

            $this->calls = $calls->map(function ($call) use ($agentMap) {
                // Get agent name from map (O(1) lookup)
                $agentName = 'Unknown';
                if ($call->agent_id && isset($agentMap[$call->agent_id])) {
                    $agentName = $agentMap[$call->agent_id]['display_name'] ??
                                $agentMap[$call->agent_id]['agent_name'] ?? 'Unknown';
                }

                return [
                    'id' => $call->id,
                    'call_id' => $call->call_id,
                    'phone_number' => $call->phone_number,
                    'to_number' => $call->to_number,
                    'agent_id' => $call->agent_id,
                    'agent_name' => $agentName,
                    'branch_name' => $call->branch?->name ?? 'N/A',
                    'customer_name' => $call->customer?->full_name ?? 'Unknown',
                    'start_time' => $call->start_timestamp?->format('Y-m-d H:i:s') ?? 'N/A',
                    'duration' => $call->duration ?? 0,
                    'duration_formatted' => $this->formatDuration($call->duration ?? 0),
                    'status' => $call->status,
                    'disconnection_reason' => $call->disconnection_reason,
                    'has_booking' => $call->appointments->isNotEmpty(), // Use already loaded relationship
                    'transcript_summary' => $call->transcript_summary,
                    'recording_url' => $call->recording_url,
                    'public_log_url' => $call->metadata['public_log_url'] ?? null,
                ];
            })
                ->toArray();
        } catch (\Exception $e) {
            Log::error('Failed to load calls', [
                'error' => $e->getMessage(),
            ]);
            $this->calls = [];
        }
    }

    /**
     * View call details.
     */
    public function viewCallDetails(string $callId): void
    {
        try {
            $call = \App\Models\Call::where('company_id', $this->companyId)
                ->where('call_id', $callId)
                ->with(['branch', 'customer', 'appointments'])
                ->first();

            if (! $call) {
                $this->error = 'Call not found';

                return;
            }

            $this->selectedCall = [
                'call_id' => $call->call_id,
                'phone_number' => $call->phone_number,
                'to_number' => $call->to_number,
                'agent_id' => $call->agent_id,
                'agent_name' => $this->getAgentName($call->agent_id),
                'branch' => $call->branch?->name ?? 'N/A',
                'customer' => $call->customer ? [
                    'name' => $call->customer->full_name,
                    'email' => $call->customer->email,
                    'phone' => $call->customer->phone,
                ] : null,
                'start_time' => $call->start_timestamp?->format('Y-m-d H:i:s'),
                'end_time' => $call->end_timestamp?->format('Y-m-d H:i:s'),
                'duration' => $this->formatDuration($call->duration ?? 0),
                'status' => $call->status,
                'disconnection_reason' => $call->disconnection_reason,
                'transcript' => $call->transcript,
                'transcript_summary' => $call->transcript_summary,
                'recording_url' => $call->recording_url,
                'public_log_url' => $call->metadata['public_log_url'] ?? null,
                'appointments' => $call->appointments->map(function ($apt) {
                    return [
                        'id' => $apt->id,
                        'date' => $apt->appointment_date,
                        'time' => $apt->appointment_time,
                        'service' => $apt->service?->name ?? 'N/A',
                        'status' => $apt->status,
                    ];
                })->toArray(),
                'metadata' => $call->metadata,
            ];

            $this->showCallDetails = true;
        } catch (\Exception $e) {
            $this->error = 'Failed to load call details: ' . $e->getMessage();
        }
    }

    /**
     * Close call details modal.
     */
    public function closeCallDetails(): void
    {
        $this->showCallDetails = false;
        $this->selectedCall = null;
    }

    /**
     * Get agent name by ID.
     */
    protected function getAgentName(string $agentId): string
    {
        $agent = collect($this->agents)->firstWhere('agent_id', $agentId);

        return $agent['display_name'] ?? $agent['agent_name'] ?? 'Unknown Agent';
    }

    /**
     * Format duration in seconds to human readable.
     */
    protected function formatDuration(int $seconds): string
    {
        if ($seconds < 60) {
            return "{$seconds}s";
        }

        $minutes = floor($seconds / 60);
        $remainingSeconds = $seconds % 60;

        if ($minutes < 60) {
            return "{$minutes}m {$remainingSeconds}s";
        }

        $hours = floor($minutes / 60);
        $remainingMinutes = $minutes % 60;

        return "{$hours}h {$remainingMinutes}m";
    }

    /**
     * Update calls when period changes.
     */
    public function updatedCallsPeriod(): void
    {
        $this->loadCalls();
    }

    /**
     * Update calls when filter changes.
     */
    public function updatedCallsFilter(): void
    {
        $this->loadCalls();
    }

    /**
     * Update calls when search changes.
     */
    public function updatedCallsSearch(): void
    {
        $this->loadCalls();
    }

    public function setDashboardFilter(string $filter, ?string $value = null): void
    {
        $this->dashboardFilter = $filter;

        if ($filter === 'phone') {
            $this->selectedPhoneFilter = $value;
            $this->selectedAgentFilter = null;
        } elseif ($filter === 'agent') {
            $this->selectedAgentFilter = $value;
            $this->selectedPhoneFilter = null;
        } else {
            $this->selectedPhoneFilter = null;
            $this->selectedAgentFilter = null;
        }

        // Reload metrics with filter
        $this->loadMetrics();
    }

    // Livewire updated hooks for filters
    public function updatedSelectedPhoneFilter($value): void
    {
        if ($this->dashboardFilter === 'phone') {
            $this->loadMetrics();
        }
    }

    public function updatedSelectedAgentFilter($value): void
    {
        if ($this->dashboardFilter === 'agent') {
            $this->loadMetrics();
        }
    }

    public function assignAgentToPhone(string $phoneNumber, ?string $agentId = null): void
    {
        try {
            Log::info('assignAgentToPhone called', [
                'phone' => $phoneNumber,
                'agent_id' => $agentId,
                'has_api_key_before' => ! empty($this->retellApiKey),
                'company_id' => $this->companyId,
                'livewire_id' => $this->getId(),
            ]);

            // Get agent ID from form state if not provided
            if ($agentId === null) {
                $sanitizedKey = str_replace(['+', '-', ' ', '(', ')'], '', $phoneNumber);
                $agentId = $this->phoneAgentAssignment[$sanitizedKey] ?? '';
            }

            if (empty($agentId)) {
                $this->error = 'Please select an agent';

                return;
            }

            // Get Retell service (will automatically fetch API key if needed)
            $retellService = $this->getRetellService();
            if (! $retellService) {
                $this->error = 'Unable to connect to Retell service. Please ensure API key is configured in Company settings.';
                Log::error('assignAgentToPhone - No Retell service', [
                    'company_id' => $this->companyId,
                ]);

                return;
            }

            // Find the agent
            $agent = collect($this->agents)->firstWhere('agent_id', $agentId);
            if (! $agent) {
                $this->error = 'Agent not found';

                return;
            }

            // Update phone number with new agent
            Log::info('Updating phone number assignment', [
                'phone' => $phoneNumber,
                'agent_id' => $agentId,
            ]);

            $result = $retellService->updatePhoneNumber($phoneNumber, [
                'inbound_agent_id' => $agentId,
            ]);

            Log::info('Phone number update result', [
                'phone' => $phoneNumber,
                'result' => $result,
            ]);

            // Update local state
            $this->phoneNumbers = collect($this->phoneNumbers)->map(function ($phone) use ($phoneNumber, $agent) {
                if ($phone['phone_number'] === $phoneNumber) {
                    $phone['agent_id'] = $agent['agent_id'];
                    $phone['inbound_agent_id'] = $agent['agent_id']; // Keep both for compatibility
                    $phone['agent_name'] = $agent['display_name'] ?? 'Unknown';
                    $phone['agent_version'] = $agent['version'] ?? 'V1';
                    $phone['agent_is_active'] = $agent['is_active'] ?? false;
                }

                return $phone;
            })->toArray();

            // Format phone number for display
            $formattedPhone = preg_replace('/(\+\d{2})(\d{2})(\d{3})(\d{2})(\d{3})/', '$1 $2 $3 $4 $5', $phoneNumber);

            $this->successMessage = "✓ Successfully assigned \"{$agent['display_name']} {$agent['version']}\" to {$formattedPhone}";

            // For now, just use the standard success message
            // The floating notification might need more debugging

            // Clear cache to ensure fresh data
            Cache::forget('retell_phone_numbers_' . auth()->id());
            Cache::forget('retell_agents_' . auth()->id());

            // Dispatch refresh without blocking
            $this->dispatch('$refresh');

            // Clear any previous errors
            $this->error = null;
        } catch (\Exception $e) {
            $this->error = 'Failed to assign agent: ' . $e->getMessage();

            // For now, just use the standard error message
            // The floating notification might need more debugging

            Log::error('Failed to assign agent to phone', [
                'phone' => $phoneNumber,
                'agent_id' => $agentId,
                'error' => $e->getMessage(),
            ]);
        }
    }

    // Computed properties
    #[Computed]
    public function filteredAgents(): array
    {
        // Ensure agents is always an array
        if (! is_array($this->agents)) {
            return [];
        }

        if (empty($this->agentSearch)) {
            return $this->agents;
        }

        $search = strtolower($this->agentSearch);

        return array_filter($this->agents, function ($agent) use ($search) {
            $name = strtolower($agent['display_name'] ?? $agent['agent_name'] ?? '');
            $id = strtolower($agent['agent_id'] ?? '');

            return str_contains($name, $search) || str_contains($id, $search);
        });
    }

    // Helper methods
    protected function parseAgentName(string $fullName): string
    {
        // Remove version numbers and clean up name
        $name = preg_replace('/\/V\d+$/', '', $fullName);

        return trim(str_replace('Online: ', '', $name));
    }

    protected function extractVersion(string $fullName): string
    {
        if (preg_match('/\/V(\d+)$/', $fullName, $matches)) {
            return 'V' . $matches[1];
        }

        return 'V1';
    }

    protected function getBaseName(string $name): string
    {
        // Get base name without version
        return $this->parseAgentName($name);
    }

    /**
     * Process agent groups from array of agents.
     */
    protected function processAgentGroups(array $agents): void
    {
        $agentGroups = collect($agents)
            ->map(function ($agent) {
                $agent['display_name'] = $this->parseAgentName($agent['agent_name'] ?? '');
                $agent['version'] = $this->extractVersion($agent['agent_name'] ?? '');
                $agent['base_name'] = $this->getBaseName($agent['agent_name'] ?? '');
                $agent['is_active'] = ($agent['status'] ?? 'inactive') === 'active';
                $agent['metrics'] = $this->getAgentMetrics($agent['agent_id'] ?? '');

                return $agent;
            })
            ->groupBy('base_name');

        $this->groupedAgents = [];
        $this->agents = [];

        foreach ($agentGroups as $baseName => $versions) {
            $sortedVersions = $versions->sortByDesc(function ($agent) {
                $score = $agent['is_active'] ? 1000 : 0;
                $versionNum = (float) str_replace('V', '', $agent['version'] ?? 'V1');

                return $score + $versionNum;
            });

            $mainAgent = $sortedVersions->first();
            $mainAgent['total_versions'] = $versions->count();
            $mainAgent['active_version'] = $sortedVersions->firstWhere('is_active');

            // Build all_versions array for dropdown with "Current" naming
            $allVersions = $sortedVersions->values();

            // Map versions with "Current" for the latest, limit to 10 versions
            $mainAgent['all_versions'] = $allVersions
                ->take(10) // Only show last 10 versions
                ->map(function ($version, $index) {
                    $isLatest = $index === 0;
                    $displayVersion = $isLatest ? 'Current' : $version['version'];

                    return [
                        'version' => $version['version'] ?? 'V1',       // Keep original for identification
                        'display_version' => $displayVersion,           // Add display version for UI
                        'agent_id' => $version['agent_id'] ?? '',
                        'is_active' => $version['is_active'] ?? false,
                        'is_latest' => $isLatest,
                    ];
                })
                ->values()
                ->toArray();

            // Set the main agent's display version
            $mainAgent['display_version'] = count($allVersions) > 0 && $sortedVersions->keys()->first() === 0 ? 'Current' : $mainAgent['version'];

            $this->agents[] = $mainAgent;

            $this->groupedAgents[$baseName] = [
                'base_name' => $baseName,
                'versions' => $sortedVersions->values()->toArray(),
            ];
        }
    }

    protected function getAgentMetrics(string $agentId): array
    {
        try {
            $todayStart = now()->startOfDay();
            $todayEnd = now()->endOfDay();
            $yesterdayStart = now()->subDay()->startOfDay();
            $yesterdayEnd = now()->subDay()->endOfDay();

            // Get today's calls for this agent
            $todaysCallsQuery = \App\Models\Call::where('company_id', $this->companyId)
                ->where('retell_agent_id', $agentId)
                ->whereBetween('created_at', [$todayStart, $todayEnd]);

            $callsToday = $todaysCallsQuery->count();

            // Get yesterday's calls for trend calculation
            $callsYesterday = \App\Models\Call::where('company_id', $this->companyId)
                ->where('retell_agent_id', $agentId)
                ->whereBetween('created_at', [$yesterdayStart, $yesterdayEnd])
                ->count();

            // Calculate trend
            $callsTrend = 0;
            if ($callsYesterday > 0) {
                $callsTrend = round((($callsToday - $callsYesterday) / $callsYesterday) * 100);
            } elseif ($callsToday > 0) {
                $callsTrend = 100; // 100% increase if yesterday was 0
            }

            // Calculate success rate (calls with appointments)
            $successfulCalls = (clone $todaysCallsQuery)
                ->whereIn('call_status', ['completed', 'analyzed'])
                ->whereExists(function ($q) {
                    $q->select(\DB::raw(1))
                        ->from('appointments')
                        ->whereColumn('appointments.call_id', 'calls.id');
                })
                ->count();

            $successRate = $callsToday > 0 ? round(($successfulCalls / $callsToday) * 100) : 0;

            // Calculate average duration
            $avgDurationSeconds = (clone $todaysCallsQuery)
                ->whereNotNull('call_length')
                ->avg('call_length') ?? 0;

            $avgDuration = sprintf('%d:%02d', floor($avgDurationSeconds / 60), $avgDurationSeconds % 60);

            // Determine status based on metrics
            $status = 'good';
            if ($successRate >= 90 && $callsToday >= 20) {
                $status = 'excellent';
            } elseif ($successRate < 70 || $callsToday < 5) {
                $status = 'warning';
            } elseif ($successRate < 50) {
                $status = 'critical';
            }

            return [
                'calls_today' => $callsToday,
                'calls_trend' => $callsTrend,
                'success_rate' => $successRate,
                'avg_duration' => $avgDuration,
                'status' => $status,
            ];
        } catch (\Exception $e) {
            Log::error('Failed to get agent metrics', [
                'agent_id' => $agentId,
                'error' => $e->getMessage(),
            ]);

            // Return default values on error
            return [
                'calls_today' => 0,
                'calls_trend' => 0,
                'success_rate' => 0,
                'avg_duration' => '0:00',
                'status' => 'unknown',
            ];
        }
    }

    // Function Builder Actions
    public function openFunctionBuilder(): void
    {
        $this->showFunctionBuilder = true;
        $this->editingFunction = [];
    }

    public function closeFunctionBuilder(): void
    {
        $this->showFunctionBuilder = false;
        $this->editingFunction = [];
    }

    public function selectFunctionTemplate(string $category, string $templateId): void
    {
        $template = collect($this->functionTemplates[$category] ?? [])
            ->firstWhere('id', $templateId);

        if ($template) {
            $this->editingFunction = $template['config'];
            $this->editingFunction['name'] = $template['name'];
            $this->editingFunction['type'] = $template['type'];
            $this->editingFunction['description'] = $template['description'];

            // Convert parameters for visual builder
            if (isset($template['config']['parameters'])) {
                $visualParams = [];
                foreach ($template['config']['parameters'] as $param) {
                    $visualParams[] = [
                        'name' => $param['name'] ?? '',
                        'type' => $param['type'] ?? 'string',
                        'required' => $param['required'] ?? false,
                        'description' => $param['description'] ?? '',
                        'default' => $param['default'] ?? '',
                    ];
                }
                $this->editingFunction['visual_parameters'] = $visualParams;
            }

            $this->dispatch('template-selected', $this->editingFunction);
        }
    }

    public function saveFunction(): void
    {
        try {
            if (! $this->selectedAgent || ! $this->llmData) {
                $this->error = 'No agent selected';

                return;
            }

            // Process parameters if they come from visual builder
            if (isset($this->editingFunction['visual_parameters'])) {
                $parameters = [];
                foreach ($this->editingFunction['visual_parameters'] as $param) {
                    $parameters[] = [
                        'name' => $param['name'],
                        'type' => $param['type'],
                        'required' => $param['required'] ?? false,
                        'description' => $param['description'] ?? '',
                        'default' => $param['default'] ?? null,
                    ];
                }
                $this->editingFunction['parameters'] = $parameters;
                unset($this->editingFunction['visual_parameters']);
            }

            // Ensure proper structure
            $function = [
                'name' => $this->editingFunction['name'] ?? '',
                'description' => $this->editingFunction['description'] ?? '',
                'url' => $this->editingFunction['url'] ?? '',
                'method' => $this->editingFunction['method'] ?? 'POST',
                'parameters' => $this->editingFunction['parameters'] ?? [],
            ];

            // Add speak messages if configured
            if (isset($this->editingFunction['speak_during_execution'])) {
                $function['speak_during_execution'] = $this->editingFunction['speak_during_execution'];
                $function['speak_during_execution_message'] = $this->editingFunction['speak_during_execution_message'] ?? '';
            }

            if (isset($this->editingFunction['speak_after_execution'])) {
                $function['speak_after_execution'] = $this->editingFunction['speak_after_execution'];
                $function['speak_after_execution_message'] = $this->editingFunction['speak_after_execution_message'] ?? '';
            }

            // Check if updating existing function
            $updatedTools = $this->llmData['general_tools'] ?? [];
            $functionIndex = null;

            foreach ($updatedTools as $index => $tool) {
                if (isset($this->editingFunction['original_name']) && $tool['name'] === $this->editingFunction['original_name']) {
                    $functionIndex = $index;

                    break;
                }
            }

            if ($functionIndex !== null) {
                // Update existing function
                $updatedTools[$functionIndex] = $function;
            } else {
                // Add new function
                $updatedTools[] = $function;
            }

            // Check if Retell service is initialized
            $retellService = $this->getRetellService();
            if (! $retellService) {
                $this->error = 'Retell service not initialized. Please check API key configuration.';

                return;
            }

            // Update LLM via API
            $result = $retellService->updateRetellLLM(
                $this->selectedAgent['response_engine']['llm_id'],
                ['general_tools' => $updatedTools]
            );

            if ($result) {
                $this->successMessage = 'Function saved successfully';
                $this->closeFunctionBuilder();

                // Reload LLM data
                Cache::forget("retell_llm_data_{$this->selectedAgent['response_engine']['llm_id']}");
                Cache::forget("retell_llm_functions_{$this->selectedAgent['response_engine']['llm_id']}");
                $this->loadLLMData($this->selectedAgent['response_engine']['llm_id']);
                $this->loadAgentFunctions();
            }
        } catch (\Exception $e) {
            $this->error = 'Failed to save function: ' . $e->getMessage();
            Log::error('Function save failed', [
                'error' => $e->getMessage(),
                'function' => $this->editingFunction,
            ]);
        }
    }

    public function deleteFunction(string $functionName): void
    {
        try {
            if (! $this->selectedAgent || ! $this->llmData) {
                $this->error = 'No agent selected';

                return;
            }

            // Remove function from LLM configuration
            $updatedTools = collect($this->llmData['general_tools'] ?? [])
                ->reject(fn ($tool) => $tool['name'] === $functionName)
                ->values()
                ->toArray();

            // Check if Retell service is initialized
            $retellService = $this->getRetellService();
            if (! $retellService) {
                $this->error = 'Retell service not initialized. Please check API key configuration.';

                return;
            }

            // Update LLM via API
            $result = $retellService->updateRetellLLM(
                $this->selectedAgent['response_engine']['llm_id'],
                ['general_tools' => $updatedTools]
            );

            if ($result) {
                $this->successMessage = 'Function deleted successfully';

                // Reload LLM data
                Cache::forget("retell_llm_data_{$this->selectedAgent['response_engine']['llm_id']}");
                $this->loadLLMData($this->selectedAgent['response_engine']['llm_id']);
            }
        } catch (\Exception $e) {
            $this->error = 'Failed to delete function: ' . $e->getMessage();
        }
    }

    // Real-time updates
    #[On('metrics-updated')]
    public function onMetricsUpdated(array $metrics): void
    {
        $this->realtimeMetrics = array_merge($this->realtimeMetrics, $metrics);
    }

    // Agent Version Selection
    public function selectAgentVersion(string $baseName, string $version): void
    {
        try {
            // First check if we have this agent in groupedAgents
            if (isset($this->groupedAgents[$baseName])) {
                $versionData = collect($this->groupedAgents[$baseName]['versions'] ?? [])
                    ->firstWhere('version', $version);

                if ($versionData && isset($versionData['agent_id'])) {
                    // Find the full agent data by agent_id
                    $agentId = $versionData['agent_id'];

                    // We need to fetch the full agent data for this version
                    // This might require loading from the API or database
                    $this->selectAgent($agentId);

                    // Update the main agent in the list to show this version
                    $this->updateAgentDisplay($baseName, $version);

                    return;
                }
            }

            // If not found, try reloading
            Cache::forget('retell_agents_' . auth()->id());
            $this->loadAgents();

            // Try again after reload
            if (isset($this->groupedAgents[$baseName])) {
                $versionData = collect($this->groupedAgents[$baseName]['versions'] ?? [])
                    ->firstWhere('version', $version);

                if ($versionData && isset($versionData['agent_id'])) {
                    $this->selectAgent($versionData['agent_id']);
                    $this->updateAgentDisplay($baseName, $version);

                    return;
                }
            }

            $this->error = "Version $version not found for agent $baseName";
        } catch (\Exception $e) {
            $this->error = 'Failed to select agent version: ' . $e->getMessage();
        }
    }

    protected function updateAgentDisplay(string $baseName, string $version): void
    {
        // Update the displayed agent to show the selected version
        foreach ($this->agents as $index => $agent) {
            if (($agent['base_name'] ?? '') === $baseName) {
                // Find the version data from groupedAgents
                if (isset($this->groupedAgents[$baseName])) {
                    $versions = collect($this->groupedAgents[$baseName]['versions'] ?? []);
                    $versionData = $versions->firstWhere('version', $version);

                    if ($versionData) {
                        // Determine if this is the latest version
                        $isLatest = $versions->first()['version'] === $version;

                        // Update the displayed version
                        $this->agents[$index]['version'] = $version;
                        $this->agents[$index]['display_version'] = $isLatest ? 'Current' : $version;
                        $this->agents[$index]['agent_id'] = $versionData['agent_id'];
                        $this->agents[$index]['is_active'] = $versionData['is_active'] ?? false;

                        // Update all_versions to reflect the selection
                        if (isset($this->agents[$index]['all_versions'])) {
                            foreach ($this->agents[$index]['all_versions'] as $vIndex => $v) {
                                if ($v['version'] === $version) {
                                    $this->agents[$index]['all_versions'][$vIndex]['is_selected'] = true;
                                } else {
                                    $this->agents[$index]['all_versions'][$vIndex]['is_selected'] = false;
                                }
                            }
                        }
                    }
                }

                break;
            }
        }
    }

    // Edit Agent
    public function editAgent(string $agentId): void
    {
        try {
            $agent = collect($this->agents)->firstWhere('agent_id', $agentId);
            if (! $agent) {
                $this->error = 'Agent not found';

                return;
            }

            $this->selectedAgent = $agent;
            $this->activeTab = 'agent-editor';

            // TODO: Implement agent editor modal/tab
            $this->dispatch('open-agent-editor', $agent);
        } catch (\Exception $e) {
            $this->error = 'Failed to open agent editor: ' . $e->getMessage();
        }
    }

    // Tab navigation method is already defined above at line 501
    // Removed duplicate method

    // Update selected agent for functions tab
    public function updatedSelectedAgentId($value): void
    {
        if (! empty($value)) {
            $this->selectAgent($value);
            $this->loadAgentFunctions();
        } else {
            $this->selectedAgent = null;
            $this->agentFunctions = [];
        }
    }

    // Handle agent search
    public function updatedAgentSearch($value): void
    {
        // The search is handled via wire:model.live in the blade template
        // This method is called when the search term changes
        // We can add additional logic here if needed
        if (empty($value)) {
            $this->loadAgents();
        }
    }

    // Function management methods
    public function editFunction(string $functionName): void
    {
        try {
            $function = collect($this->agentFunctions)->firstWhere('name', $functionName);
            if ($function) {
                $this->editingFunction = $function;
                $this->editingFunction['original_name'] = $functionName; // Track original name for updates

                // Convert parameters for visual builder
                if (isset($function['parameters']) && is_array($function['parameters'])) {
                    $this->editingFunction['visual_parameters'] = $function['parameters'];
                }

                $this->showFunctionBuilder = true;
            }
        } catch (\Exception $e) {
            $this->error = 'Failed to edit function: ' . $e->getMessage();
        }
    }

    public function testFunction(string $functionName): void
    {
        try {
            // TODO: Implement function testing logic
            $this->successMessage = "Test initiated for function: {$functionName}";

            // Dispatch event for function test modal
            $this->dispatch('test-function', [
                'function' => collect($this->agentFunctions)->firstWhere('name', $functionName),
                'agent' => $this->selectedAgent,
            ]);
        } catch (\Exception $e) {
            $this->error = 'Failed to test function: ' . $e->getMessage();
        }
    }

    public function duplicateFunction(string $functionName): void
    {
        try {
            $function = collect($this->agentFunctions)->firstWhere('name', $functionName);
            if ($function) {
                $newFunction = $function;
                $newFunction['name'] = $function['name'] . '_copy';
                $newFunction['description'] = ($function['description'] ?? '') . ' (Copy)';

                $this->editingFunction = $newFunction;
                $this->showFunctionBuilder = true;
            }
        } catch (\Exception $e) {
            $this->error = 'Failed to duplicate function: ' . $e->getMessage();
        }
    }

    public function viewFunctionLogs(string $functionName): void
    {
        try {
            // TODO: Implement function logs viewer
            $this->dispatch('view-function-logs', [
                'function_name' => $functionName,
                'agent_id' => $this->selectedAgent['agent_id'] ?? null,
            ]);
        } catch (\Exception $e) {
            $this->error = 'Failed to view function logs: ' . $e->getMessage();
        }
    }

    // Test Call
    public function testCall(string $agentId): void
    {
        try {
            $retellService = $this->getRetellService();
            if (! $retellService) {
                $this->error = 'Retell service not initialized. Please check API key configuration.';

                return;
            }

            $agent = collect($this->agents)->firstWhere('agent_id', $agentId);
            if (! $agent) {
                $this->error = 'Agent not found';

                return;
            }

            // Get test phone number from company settings or use default
            $testPhoneNumber = auth()->user()->company->test_phone_number ?? config('services.retell.test_phone_number');

            if (! $testPhoneNumber) {
                $this->error = 'No test phone number configured. Please set one in company settings.';

                return;
            }

            // Start test call via Retell API
            $result = $retellService->createPhoneCall([
                'from_number' => '+4930123456789', // Your Retell phone number
                'to_number' => $testPhoneNumber,
                'agent_id' => $agentId,
                'metadata' => [
                    'test_call' => true,
                    'initiated_by' => auth()->id(),
                    'agent_name' => $agent['display_name'] ?? 'Unknown',
                ],
            ]);

            if (isset($result['call_id'])) {
                $this->successMessage = "Test call initiated to {$testPhoneNumber}. Call ID: {$result['call_id']}";

                // Track the test call
                $this->dispatch('test-call-started', [
                    'call_id' => $result['call_id'],
                    'agent_id' => $agentId,
                ]);
            } else {
                $this->error = 'Failed to initiate test call';
            }
        } catch (\Exception $e) {
            $this->error = 'Failed to start test call: ' . $e->getMessage();
            Log::error('Test call failed', [
                'agent_id' => $agentId,
                'error' => $e->getMessage(),
            ]);
        }
    }

    // Open Agent Creator
    public function openAgentCreator(): void
    {
        // TODO: Implement agent creation modal
        $this->dispatch('open-agent-creator');

        // For now, just show a message
        $this->successMessage = 'Agent creator coming soon! Use Retell.ai dashboard for now.';
    }

    // Agent Editor Methods
    public array $agentVersions = [];

    public string $agentEditorMode = 'edit'; // edit, create_new, duplicate

    // Full Agent Editor Properties
    public array $editingAgentFull = [];

    public array $editingLLM = [];

    public array $editingFunctions = [];

    public array $editingPostCallAnalysis = [];

    public bool $showFullEditor = false;

    public string $editorActiveTab = 'basic';

    public array $editingWebhookSettings = [];

    public array $originalAgentData = []; // For tracking changes

    public function openAgentEditor(string $agentId): void
    {
        try {
            Log::info('openAgentEditor called', [
                'agentId' => $agentId,
                'user' => auth()->user()->email ?? 'unknown',
                'properties_exist' => [
                    'showAgentEditor' => property_exists($this, 'showAgentEditor'),
                    'selectedAgentId' => property_exists($this, 'selectedAgentId'),
                    'activeTab' => property_exists($this, 'activeTab'),
                ]
            ]);
            
            // Load agent data for editing
            $this->selectedAgentId = $agentId;
            $this->loadAgentDetails($agentId);
            $this->showAgentEditor = true;

            // Switch to agents tab to show the editor
            $this->activeTab = 'agents';
            
            Log::info('openAgentEditor completed successfully', [
                'showAgentEditor' => $this->showAgentEditor,
                'activeTab' => $this->activeTab
            ]);
        } catch (\Exception $e) {
            Log::error('Error in openAgentEditor', [
                'agentId' => $agentId,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            $this->error = 'Failed to open agent editor: ' . $e->getMessage();
        }
    }

    public function closeAgentEditor(): void
    {
        $this->showAgentEditor = false;
        $this->showFullEditor = false;
        $this->editingAgent = [];
        $this->editingAgentFull = [];
        $this->editingLLM = [];
        $this->editingFunctions = [];
        $this->editingPostCallAnalysis = [];
        $this->editingWebhookSettings = [];
        $this->originalAgentData = [];
        $this->agentVersions = [];
    }

    public function loadAgentDetails(string $agentId): void
    {
        try {
            Log::info('loadAgentDetails called', ['agentId' => $agentId]);
            
            // Find the agent in the loaded agents array
            $agent = collect($this->agents)->firstWhere('agent_id', $agentId);

            if (! $agent) {
                // Try to load from database
                $dbAgent = \App\Models\RetellAgent::where('agent_id', $agentId)
                    ->where('company_id', $this->companyId)
                    ->first();

                if ($dbAgent) {
                    $agent = $dbAgent->toArray();
                } else {
                    $this->error = 'Agent not found';
                    Log::warning('Agent not found', ['agentId' => $agentId, 'companyId' => $this->companyId]);
                    return;
                }
            }
            
            // Ensure agent is an array
            if (!is_array($agent)) {
                $this->error = 'Invalid agent data';
                Log::error('Agent data is not an array', ['agent' => $agent]);
                return;
            }

            // Set up editing data
            $this->editingAgent = [
                'agent_id' => $agent['agent_id'] ?? '',
                'agent_name' => $agent['agent_name'] ?? '',
                'base_name' => $agent['base_name'] ?? $this->parseAgentName($agent['agent_name'] ?? ''),
                'voice_id' => $agent['voice_id'] ?? '',
                'language' => $agent['language'] ?? 'de',
                'responsiveness' => $agent['responsiveness'] ?? 1,
                'interruption_sensitivity' => $agent['interruption_sensitivity'] ?? 1,
                'enable_backchannel' => $agent['enable_backchannel'] ?? true,
                'ambient_sound' => $agent['ambient_sound'] ?? null,
                'webhook_url' => $agent['webhook_url'] ?? '',
                'enable_voicemail_detection' => $agent['enable_voicemail_detection'] ?? false,
                'voicemail_message' => $agent['voicemail_message'] ?? '',
                'end_call_after_silence_ms' => $agent['end_call_after_silence_ms'] ?? 30000,
                'max_call_duration_ms' => $agent['max_call_duration_ms'] ?? 3600000,
                'pronunciation_guide' => $agent['pronunciation_guide'] ?? [],
            ];

            // Store full agent data for advanced editing
            // If agent has a configuration field (from database), extract fields from it
            if (isset($agent['configuration']) && is_array($agent['configuration'])) {
                $extractedFields = $this->extractAgentFields($agent['configuration']);
                $this->editingAgentFull = array_merge($agent, $extractedFields);
            } else {
                $this->editingAgentFull = $agent;
            }
            $this->originalAgentData = $agent;
            
            // Ensure base_name exists for version management
            if (!isset($this->editingAgentFull['base_name'])) {
                $this->editingAgentFull['base_name'] = $agent['agent_name'] ?? 'Agent';
            }

            // Load LLM settings - safe array access
            $llmModel = 'gpt-4'; // default
            if (!empty($agent['llm_websocket_url'])) {
                $llmModel = $agent['llm_websocket_url'];
            } elseif (isset($agent['llm']) && is_array($agent['llm']) && isset($agent['llm']['model'])) {
                $llmModel = $agent['llm']['model'];
            }
            
            // Get prompt from proper field
            $systemPrompt = '';
            if (isset($agent['prompt']) && is_array($agent['prompt']) && isset($agent['prompt']['prompt'])) {
                $systemPrompt = $agent['prompt']['prompt'];
            } elseif (isset($agent['prompt']) && is_string($agent['prompt'])) {
                $systemPrompt = $agent['prompt'];
            }
            
            $this->editingLLM = [
                'model' => $llmModel,
                'system_prompt' => $systemPrompt,
                'temperature' => $agent['temperature'] ?? 0.7,
                'max_tokens' => $agent['max_tokens'] ?? 150,
                'functions' => $agent['functions'] ?? [],
            ];

            // Load functions
            $this->editingFunctions = $agent['functions'] ?? [];

            // Load post-call analysis
            $this->editingPostCallAnalysis = $agent['post_call_analysis_data'] ?? [];

            // Load webhook settings - fix key name to match blade template expectation
            $this->editingWebhookSettings = [
                'url' => $agent['webhook_url'] ?? '',  // Changed from 'webhook_url' to 'url'
                'enable_webhook_for_create_call' => $agent['enable_webhook_for_create_call'] ?? false,
                'opt_out_sensitive_data_storage' => $agent['opt_out_sensitive_data_storage'] ?? false,
            ];
        } catch (\Exception $e) {
            $this->error = 'Error loading agent details: ' . $e->getMessage();
            Log::error('Failed to load agent details', [
                'agent_id' => $agentId,
                'error' => $e->getMessage(),
            ]);
        }
        $this->agentEditorMode = 'edit';
        $this->editorActiveTab = 'basic';
    }

    public function saveAgent(): void
    {
        try {
            if ($this->agentEditorMode === 'create_new') {
                // Create new version
                $this->createVersion();
            } else {
                // Update existing agent
                $agentId = $this->editingAgent['agent_id'] ?? null;
                if (! $agentId) {
                    $this->error = 'No agent ID found';

                    return;
                }

                // Prepare update data
                $updateData = [
                    'agent_name' => $this->editingAgent['agent_name'] ?? '',
                    'prompt' => [
                        'prompt' => $this->editingAgent['prompt']['prompt'] ?? '',
                    ],
                    'voice_id' => $this->editingAgent['voice_id'] ?? 'openai-Alloy',
                    'interruption_sensitivity' => $this->editingAgent['interruption_sensitivity'] ?? 1,
                    'ambient_sound' => $this->editingAgent['ambient_sound'] ?? null,
                    'language' => $this->editingAgent['language'] ?? 'en-US',
                    'temperature' => $this->editingAgent['temperature'] ?? 0.7,
                    'response_engine' => $this->editingAgent['response_engine'] ?? [
                        'type' => 'retell-llm',
                        'llm_id' => $this->editingAgent['response_engine']['llm_id'] ?? null,
                    ],
                ];

                // Check if Retell service is initialized
                $retellService = $this->getRetellService();
                if (! $retellService) {
                    $this->error = 'Retell service not initialized. Please check API key configuration.';

                    return;
                }

                // Update via Retell API
                $result = $retellService->updateAgent($agentId, $updateData);

                if ($result) {
                    $this->successMessage = 'Agent updated successfully';

                    // Update local state
                    $this->agents = collect($this->agents)->map(function ($agent) use ($agentId, $result) {
                        if ($agent['agent_id'] === $agentId) {
                            return array_merge($agent, $result);
                        }

                        return $agent;
                    })->toArray();

                    // Clear cache
                    Cache::forget('retell_agents_' . auth()->id());

                    $this->closeAgentEditor();
                } else {
                    $this->error = 'Failed to update agent';
                }
            }
        } catch (\Exception $e) {
            $this->error = 'Failed to save agent: ' . $e->getMessage();
            Log::error('Failed to save agent', [
                'agent' => $this->editingAgent,
                'error' => $e->getMessage(),
            ]);
        }
    }

    public function createVersion(): void
    {
        try {
            $baseName = $this->editingAgent['base_name'] ?? $this->editingAgent['agent_name'];

            // Find highest version number
            $versions = collect($this->agents)
                ->filter(function ($agent) use ($baseName) {
                    return ($agent['base_name'] ?? $agent['agent_name']) === $baseName;
                })
                ->pluck('version')
                ->map(function ($version) {
                    preg_match('/V(\d+)/', $version ?? 'V1', $matches);

                    return isset($matches[1]) ? (int) $matches[1] : 1;
                })
                ->max() ?? 0;

            $newVersion = 'V' . ($versions + 1);

            // Prepare new agent data
            $newAgentData = [
                'agent_name' => $baseName . ' ' . $newVersion,
                'prompt' => $this->editingAgent['prompt'] ?? ['prompt' => ''],
                'voice_id' => $this->editingAgent['voice_id'] ?? 'openai-Alloy',
                'interruption_sensitivity' => $this->editingAgent['interruption_sensitivity'] ?? 1,
                'ambient_sound' => $this->editingAgent['ambient_sound'] ?? null,
                'language' => $this->editingAgent['language'] ?? 'en-US',
                'temperature' => $this->editingAgent['temperature'] ?? 0.7,
                'response_engine' => $this->editingAgent['response_engine'] ?? [
                    'type' => 'retell-llm',
                    'llm_id' => $this->editingAgent['response_engine']['llm_id'] ?? null,
                ],
                'metadata' => [
                    'base_name' => $baseName,
                    'version' => $newVersion,
                    'created_from' => $this->editingAgent['agent_id'] ?? null,
                    'created_at' => now()->toIso8601String(),
                ],
            ];

            // Check if Retell service is initialized
            $retellService = $this->getRetellService();
            if (! $retellService) {
                $this->error = 'Retell service not initialized. Please check API key configuration.';

                return;
            }

            // Create via Retell API
            $result = $retellService->createAgent($newAgentData);

            if ($result && isset($result['agent_id'])) {
                $this->successMessage = "New version {$newVersion} created successfully";

                // Add to local state
                $result['base_name'] = $baseName;
                $result['version'] = $newVersion;
                $result['display_name'] = $baseName;
                $result['is_active'] = true;

                $this->agents[] = $result;

                // Clear cache
                Cache::forget('retell_agents_' . auth()->id());

                $this->closeAgentEditor();

                // Reload agents
                $this->loadAgents();
            } else {
                $this->error = 'Failed to create new version';
            }
        } catch (\Exception $e) {
            $this->error = 'Failed to create version: ' . $e->getMessage();
            Log::error('Failed to create agent version', [
                'agent' => $this->editingAgent,
                'error' => $e->getMessage(),
            ]);
        }
    }

    public function activateAgentVersion(string $agentId): void
    {
        try {
            $agent = collect($this->agents)->firstWhere('agent_id', $agentId);
            if (! $agent) {
                $this->error = 'Agent not found';

                return;
            }

            $baseName = $agent['base_name'] ?? $agent['display_name'];

            // Update all agents with same base name
            $this->agents = collect($this->agents)->map(function ($a) use ($baseName, $agentId) {
                if (($a['base_name'] ?? $a['display_name']) === $baseName) {
                    $a['is_active'] = $a['agent_id'] === $agentId;
                }

                return $a;
            })->toArray();

            // Update phone numbers to use this agent
            $phoneNumbers = collect($this->phoneNumbers)
                ->filter(function ($phone) use ($baseName) {
                    $currentAgent = collect($this->agents)->firstWhere('agent_id', $phone['agent_id'] ?? '');

                    return $currentAgent && ($currentAgent['base_name'] ?? $currentAgent['display_name']) === $baseName;
                })
                ->pluck('phone_number');

            foreach ($phoneNumbers as $phoneNumber) {
                try {
                    $retellService = $this->getRetellService();
                    if ($retellService) {
                        $retellService->updatePhoneNumber($phoneNumber, [
                            'agent_id' => $agentId,
                        ]);
                    }
                } catch (\Exception $e) {
                    Log::error('Failed to update phone number', [
                        'phone' => $phoneNumber,
                        'agent_id' => $agentId,
                        'error' => $e->getMessage(),
                    ]);
                }
            }

            $this->successMessage = "Agent {$agent['display_name']} {$agent['version']} activated";

            // Clear caches
            Cache::forget('retell_agents_' . auth()->id());
            Cache::forget('retell_phone_numbers_' . auth()->id());

            // Reload data
            $this->loadPhoneNumbers();
        } catch (\Exception $e) {
            $this->error = 'Failed to activate agent version: ' . $e->getMessage();
            Log::error('Failed to activate agent version', [
                'agent_id' => $agentId,
                'error' => $e->getMessage(),
            ]);
        }
    }

    public function setAgentEditorMode(string $mode): void
    {
        $this->agentEditorMode = $mode;
    }

    public function switchEditorTab(string $tab): void
    {
        $this->editorActiveTab = $tab;
    }

    // Performance Dashboard Methods

    public function openPerformanceDashboard(string $agentId): void
    {
        try {
            $agent = collect($this->agents)->firstWhere('agent_id', $agentId);
            if (! $agent) {
                $this->error = 'Agent not found';

                return;
            }

            $this->performanceAgent = $agent;
            $this->loadPerformanceMetrics();
            $this->showPerformanceDashboard = true;
        } catch (\Exception $e) {
            $this->error = 'Failed to open performance dashboard: ' . $e->getMessage();
            Log::error('Failed to open performance dashboard', [
                'agent_id' => $agentId,
                'error' => $e->getMessage(),
            ]);
        }
    }

    public function closePerformanceDashboard(): void
    {
        $this->showPerformanceDashboard = false;
        $this->performanceAgent = null;
        $this->performanceMetrics = [];
    }

    public function updatePerformancePeriod(string $period): void
    {
        $this->performancePeriod = $period;
        $this->loadPerformanceMetrics();
    }

    public function refreshPerformanceData(): void
    {
        $this->loadPerformanceMetrics();
        $this->successMessage = 'Performance data refreshed';
    }

    protected function loadPerformanceMetrics(): void
    {
        try {
            if (! $this->performanceAgent) {
                return;
            }

            $retellService = $this->getRetellService();
            if (! $retellService) {
                $this->performanceMetrics = [];

                return;
            }

            $agentId = $this->performanceAgent['agent_id'];

            // Calculate date range based on period
            $endDate = now();
            $startDate = match ($this->performancePeriod) {
                '24h' => now()->subHours(24),
                '7d' => now()->subDays(7),
                '30d' => now()->subDays(30),
                '90d' => now()->subDays(90),
                default => now()->subDays(7)
            };

            // Get calls for this agent
            $calls = $retellService->listCalls(1000);
            $agentCalls = collect($calls['calls'] ?? [])
                ->filter(function ($call) use ($agentId, $startDate, $endDate) {
                    $callTime = \Carbon\Carbon::parse($call['start_timestamp'] ?? '');

                    return $call['agent_id'] === $agentId &&
                           $callTime->between($startDate, $endDate);
                });

            // Calculate metrics
            $totalCalls = $agentCalls->count();
            $successfulCalls = $agentCalls->filter(function ($call) {
                return ($call['disconnection_reason'] ?? '') === 'customer_hung_up' ||
                       ($call['disconnection_reason'] ?? '') === 'call_transfer' ||
                       str_contains(strtolower($call['transcript'] ?? ''), 'appointment');
            })->count();

            $totalDuration = $agentCalls->sum('call_length') ?? 0;
            $avgDuration = $totalCalls > 0 ? $totalDuration / $totalCalls : 0;

            // Calculate costs (approximate)
            $costPerMinute = 0.10; // $0.10 per minute
            $totalCost = ($totalDuration / 60) * $costPerMinute;

            // Calculate trends (compare to previous period)
            $previousEndDate = $startDate;
            $previousStartDate = match ($this->performancePeriod) {
                '24h' => $startDate->copy()->subHours(24),
                '7d' => $startDate->copy()->subDays(7),
                '30d' => $startDate->copy()->subDays(30),
                '90d' => $startDate->copy()->subDays(90),
                default => $startDate->copy()->subDays(7)
            };

            $previousCalls = collect($calls['calls'] ?? [])
                ->filter(function ($call) use ($agentId, $previousStartDate, $previousEndDate) {
                    $callTime = \Carbon\Carbon::parse($call['start_timestamp'] ?? '');

                    return $call['agent_id'] === $agentId &&
                           $callTime->between($previousStartDate, $previousEndDate);
                })->count();

            $callsTrend = $previousCalls > 0 ?
                round((($totalCalls - $previousCalls) / $previousCalls) * 100, 1) : 0;

            // Calculate outcome breakdown
            $outcomes = [
                'Appointment Booked' => [
                    'count' => $agentCalls->filter(
                        fn ($call) => str_contains(strtolower($call['transcript'] ?? ''), 'appointment')
                    )->count(),
                    'color' => '#10b981',
                    'percentage' => 0,
                ],
                'Information Provided' => [
                    'count' => $agentCalls->filter(
                        fn ($call) => ! str_contains(strtolower($call['transcript'] ?? ''), 'appointment') &&
                        ($call['call_length'] ?? 0) > 30
                    )->count(),
                    'color' => '#3b82f6',
                    'percentage' => 0,
                ],
                'Call Transferred' => [
                    'count' => $agentCalls->filter(
                        fn ($call) => ($call['disconnection_reason'] ?? '') === 'call_transfer'
                    )->count(),
                    'color' => '#8b5cf6',
                    'percentage' => 0,
                ],
                'Customer Hung Up' => [
                    'count' => $agentCalls->filter(
                        fn ($call) => ($call['disconnection_reason'] ?? '') === 'customer_hung_up' &&
                        ! str_contains(strtolower($call['transcript'] ?? ''), 'appointment')
                    )->count(),
                    'color' => '#ef4444',
                    'percentage' => 0,
                ],
                'Technical Error' => [
                    'count' => $agentCalls->filter(
                        fn ($call) => str_contains(($call['disconnection_reason'] ?? ''), 'error')
                    )->count(),
                    'color' => '#f59e0b',
                    'percentage' => 0,
                ],
            ];

            // Calculate percentages
            if ($totalCalls > 0) {
                foreach ($outcomes as $key => &$outcome) {
                    $outcome['percentage'] = round(($outcome['count'] / $totalCalls) * 100, 1);
                }
            }

            // Set metrics
            $this->performanceMetrics = [
                'total_calls' => $totalCalls,
                'calls_trend' => $callsTrend,
                'success_rate' => $totalCalls > 0 ? round(($successfulCalls / $totalCalls) * 100, 1) : 0,
                'avg_duration' => gmdate('i:s', $avgDuration),
                'duration_comparison' => 'vs ' . gmdate('i:s', 222) . ' average',
                'total_cost' => $totalCost,
                'cost_per_call' => $totalCalls > 0 ? $totalCost / $totalCalls : 0,
                'customer_rating' => $this->calculateCustomerRating($agentCalls),
                'avg_response_time' => $this->calculateAvgResponseTime($agentCalls),
                'response_quality' => 'Good',
                'outcomes' => $outcomes,
                'cost_breakdown' => [
                    'api' => $totalCost * 0.7,
                    'telephony' => $totalCost * 0.3,
                ],
                // Time series data for charts
                'time_series' => $this->generateTimeSeriesData($agentCalls, $startDate, $endDate),
            ];
        } catch (\Exception $e) {
            $this->error = 'Failed to load performance metrics: ' . $e->getMessage();
            Log::error('Failed to load performance metrics', [
                'agent' => $this->performanceAgent,
                'error' => $e->getMessage(),
            ]);
        }
    }

    protected function generateTimeSeriesData($calls, $startDate, $endDate): array
    {
        $interval = match ($this->performancePeriod) {
            '24h' => 'hour',
            '7d' => 'day',
            '30d' => 'day',
            '90d' => 'week',
            default => 'day'
        };

        $data = [];
        $current = $startDate->copy();

        while ($current <= $endDate) {
            $periodEnd = $current->copy();
            if ($interval === 'hour') {
                $periodEnd->addHour();
            } elseif ($interval === 'day') {
                $periodEnd->addDay();
            } else {
                $periodEnd->addWeek();
            }

            $periodCalls = $calls->filter(function ($call) use ($current, $periodEnd) {
                $callTime = \Carbon\Carbon::parse($call['start_timestamp'] ?? '');

                return $callTime->between($current, $periodEnd);
            });

            $data[] = [
                'label' => $interval === 'hour' ? $current->format('H:i') : $current->format('M d'),
                'calls' => $periodCalls->count(),
                'success_rate' => $periodCalls->count() > 0 ?
                    round($periodCalls->filter(
                        fn ($call) => str_contains(strtolower($call['transcript'] ?? ''), 'appointment')
                    )->count() / $periodCalls->count() * 100, 1) : 0,
                'avg_duration' => $periodCalls->avg('call_length') ?? 0,
                'cost' => ($periodCalls->sum('call_length') ?? 0) / 60 * 0.10,
            ];

            $current = $periodEnd;
        }

        return $data;
    }

    public function exportPerformanceReport(string $format): void
    {
        try {
            if (! $this->performanceAgent || empty($this->performanceMetrics)) {
                $this->error = 'No performance data to export';

                return;
            }

            // TODO: Implement actual export functionality
            $this->successMessage = "Export to {$format} initiated. Check your downloads.";

            // Log export request
            Log::info('Performance report export requested', [
                'agent' => $this->performanceAgent['agent_id'],
                'format' => $format,
                'period' => $this->performancePeriod,
                'user' => auth()->id(),
            ]);
        } catch (\Exception $e) {
            $this->error = 'Failed to export report: ' . $e->getMessage();
        }
    }

    /**
     * Load default settings from company.
     */
    protected function loadDefaultSettings(): void
    {
        try {
            if ($this->companyId) {
                $company = Company::find($this->companyId);
                if ($company && $company->retell_default_settings) {
                    $savedSettings = $company->retell_default_settings;
                    if (is_array($savedSettings)) {
                        $this->defaultSettings = array_merge($this->defaultSettings, [
                            'voice_id' => $savedSettings['default_voice_id'] ?? $this->defaultSettings['voice_id'],
                            'language' => $savedSettings['default_language'] ?? $this->defaultSettings['language'],
                            'interruption_sensitivity' => $savedSettings['default_interruption_sensitivity'] ?? $this->defaultSettings['interruption_sensitivity'],
                            'response_speed' => $savedSettings['default_response_speed'] ?? $this->defaultSettings['response_speed'],
                        ]);
                    }
                }
            }
        } catch (\Exception $e) {
            Log::warning('Failed to load default settings', [
                'error' => $e->getMessage(),
                'company_id' => $this->companyId,
            ]);
        }
    }

    /**
     * Save default voice settings.
     */
    public function saveDefaultSettings(): void
    {
        try {
            // Save to company settings
            if ($this->companyId) {
                $company = Company::find($this->companyId);
                if ($company) {
                    // Store settings as JSON in company table or settings table
                    $settings = [
                        'default_voice_id' => $this->defaultSettings['voice_id'],
                        'default_language' => $this->defaultSettings['language'],
                        'default_interruption_sensitivity' => $this->defaultSettings['interruption_sensitivity'],
                        'default_response_speed' => $this->defaultSettings['response_speed'],
                    ];

                    // Update company settings
                    $company->update([
                        'retell_default_settings' => json_encode($settings),
                    ]);

                    $this->successMessage = 'Default voice settings saved successfully';

                    Log::info('Default voice settings saved', [
                        'company_id' => $this->companyId,
                        'settings' => $settings,
                    ]);
                }
            }
        } catch (\Exception $e) {
            $this->error = 'Failed to save settings: ' . $e->getMessage();
            Log::error('Failed to save default settings', [
                'error' => $e->getMessage(),
                'company_id' => $this->companyId,
            ]);
        }
    }

    /**
     * Test webhook endpoint.
     */
    public function testWebhook(): void
    {
        try {
            $webhookUrl = config('app.url') . '/api/retell/webhook';

            // Create test payload
            $testPayload = [
                'event_type' => 'test',
                'call_id' => 'test_' . uniqid(),
                'timestamp' => now()->toIso8601String(),
                'test' => true,
                'message' => 'This is a test webhook from Retell Ultimate Control Center',
            ];

            // Send test webhook
            $response = Http::timeout(10)
                ->withHeaders([
                    'Content-Type' => 'application/json',
                    'x-retell-signature' => $this->generateWebhookSignature($testPayload),
                ])
                ->post($webhookUrl, $testPayload);

            if ($response->successful()) {
                $this->webhookTestResult = [
                    'success' => true,
                    'message' => 'Test webhook sent successfully!',
                ];
            } else {
                $this->webhookTestResult = [
                    'success' => false,
                    'message' => 'Failed: ' . $response->status() . ' - ' . $response->body(),
                ];
            }

            Log::info('Test webhook sent', [
                'url' => $webhookUrl,
                'response_status' => $response->status(),
                'success' => $response->successful(),
            ]);
        } catch (\Exception $e) {
            $this->webhookTestResult = [
                'success' => false,
                'message' => 'Error: ' . $e->getMessage(),
            ];

            Log::error('Failed to send test webhook', [
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * Load webhook event logs.
     */
    public function loadWebhookLogs(): void
    {
        try {
            // Check if webhook_events table exists
            if (! \Schema::hasTable('webhook_events')) {
                $this->webhookLogs = [];
                $this->webhookStats = [
                    'total' => 0,
                    'success' => 0,
                    'failed' => 0,
                    'avg_response_time' => 0,
                ];

                return;
            }

            // Load webhook events from database
            $logs = \DB::table('webhook_events')
                ->where('provider', 'retell')
                ->when($this->companyId, function ($query) {
                    return $query->where('company_id', $this->companyId);
                })
                ->orderBy('created_at', 'desc')
                ->limit(50)
                ->get()
                ->map(function ($log) {
                    $payload = json_decode($log->payload, true) ?? [];

                    return [
                        'event_type' => $log->event_type ?? $payload['event_type'] ?? 'unknown',
                        'call_id' => $payload['call_id'] ?? null,
                        'phone_number' => $payload['from_number'] ?? $payload['to_number'] ?? null,
                        'duration' => $payload['call_length'] ?? null,
                        'status' => $log->status ?? 'unknown',
                        'created_at' => $log->created_at,
                        'error' => $log->error_message ?? null,
                    ];
                })
                ->toArray();

            $this->webhookLogs = $logs;

            // Calculate statistics for last 24 hours
            $stats = \DB::table('webhook_events')
                ->where('provider', 'retell')
                ->where('created_at', '>=', now()->subDay())
                ->when($this->companyId, function ($query) {
                    return $query->where('company_id', $this->companyId);
                })
                ->selectRaw('
                    COUNT(*) as total,
                    SUM(CASE WHEN status = "processed" THEN 1 ELSE 0 END) as success,
                    SUM(CASE WHEN status = "failed" THEN 1 ELSE 0 END) as failed,
                    0 as avg_response_time
                ')
                ->first();

            $this->webhookStats = [
                'total' => $stats->total ?? 0,
                'success' => $stats->success ?? 0,
                'failed' => $stats->failed ?? 0,
                'avg_response_time' => round($stats->avg_response_time ?? 0, 2),
            ];

            Log::info('Webhook logs loaded', [
                'count' => count($this->webhookLogs),
                'stats' => $this->webhookStats,
            ]);
        } catch (\Exception $e) {
            $this->error = 'Failed to load webhook logs: ' . $e->getMessage();
            Log::error('Failed to load webhook logs', [
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * Generate webhook signature for testing.
     */
    private function generateWebhookSignature(array $payload): string
    {
        $secret = config('services.retell.webhook_secret', '');
        $payloadString = json_encode($payload);

        return hash_hmac('sha256', $payloadString, $secret);
    }

    /**
     * Calculate agent utilization percentage.
     */
    private function calculateAgentUtilization(): int
    {
        try {
            // Get working hours for today (assuming 8 hours)
            $workingHoursInSeconds = 8 * 60 * 60; // 8 hours

            // Get total call duration for today
            $todayStart = now()->startOfDay();
            $todayEnd = now()->endOfDay();

            $query = \App\Models\Call::query()
                ->where('company_id', $this->companyId)
                ->whereBetween('created_at', [$todayStart, $todayEnd])
                ->whereIn('call_status', ['completed', 'analyzed']);

            // Apply filters if set
            if ($this->dashboardFilter === 'agent' && $this->selectedAgentFilter) {
                $query->where('retell_agent_id', $this->selectedAgentFilter);
            }

            // Sum call durations (call_length is in seconds)
            $totalCallDuration = $query->sum('call_length') ?? 0;

            // Calculate utilization percentage
            $utilization = $workingHoursInSeconds > 0
                ? round(($totalCallDuration / $workingHoursInSeconds) * 100)
                : 0;

            // Cap at 100%
            return min($utilization, 100);
        } catch (\Exception $e) {
            Log::error('Failed to calculate agent utilization', [
                'error' => $e->getMessage(),
            ]);

            return 0;
        }
    }

    /**
     * Calculate customer rating from calls.
     */
    private function calculateCustomerRating($agentCalls): float
    {
        // For now, calculate based on success rate and call duration
        // In future, this could use actual customer feedback data
        try {
            $totalCalls = $agentCalls->count();
            if ($totalCalls === 0) {
                return 4.0; // Default rating
            }

            // Count successful outcomes
            $successfulCalls = $agentCalls->filter(function ($call) {
                return str_contains(strtolower($call['transcript'] ?? ''), 'appointment');
            })->count();

            // Base rating starts at 3.0
            $rating = 3.0;

            // Add points for success rate
            $successRate = $successfulCalls / $totalCalls;
            $rating += $successRate * 1.5; // Max 1.5 points for 100% success

            // Add points for quick resolution (calls under 5 minutes)
            $quickCalls = $agentCalls->filter(function ($call) {
                return ($call['call_length'] ?? 0) < 300; // 5 minutes
            })->count();
            $quickRate = $quickCalls / $totalCalls;
            $rating += $quickRate * 0.5; // Max 0.5 points for quick resolution

            // Cap at 5.0
            return min(round($rating, 1), 5.0);
        } catch (\Exception $e) {
            Log::error('Failed to calculate customer rating', [
                'error' => $e->getMessage(),
            ]);

            return 4.0;
        }
    }

    /**
     * Calculate average response time.
     */
    private function calculateAvgResponseTime($agentCalls): int
    {
        try {
            // Calculate average time from call start to first agent response
            // For now, we'll estimate based on call data
            $validCalls = $agentCalls->filter(function ($call) {
                return isset($call['start_timestamp']) && isset($call['created_at']);
            });

            if ($validCalls->isEmpty()) {
                return 100; // Default 100ms
            }

            $totalResponseTime = 0;
            foreach ($validCalls as $call) {
                // Calculate response time in milliseconds
                $created = \Carbon\Carbon::parse($call['created_at']);
                $started = \Carbon\Carbon::parse($call['start_timestamp']);
                $responseTime = $started->diffInMilliseconds($created);
                $totalResponseTime += $responseTime;
            }

            $avgResponseTime = $totalResponseTime / $validCalls->count();

            // Return a reasonable value (between 50ms and 300ms)
            return max(50, min(300, round($avgResponseTime)));
        } catch (\Exception $e) {
            Log::error('Failed to calculate avg response time', [
                'error' => $e->getMessage(),
            ]);

            return 100; // Default 100ms
        }
    }

    /**
     * Export agent configuration as JSON.
     */
    public function exportAgent(string $agentId): void
    {
        try {
            $retellService = $this->getRetellService();
            if (! $retellService) {
                $this->error = 'Retell service not configured';

                return;
            }

            // Get full agent configuration from API
            $agent = $retellService->getAgent($agentId);
            if (! $agent) {
                $this->error = 'Agent not found';

                return;
            }

            // Remove sensitive data before export
            $exportData = $this->sanitizeAgentForExport($agent);

            // Add metadata for import
            $exportData['_export_metadata'] = [
                'exported_at' => now()->toIso8601String(),
                'exported_by' => auth()->user()->email,
                'askproai_version' => '1.0',
                'original_agent_id' => $agentId,
            ];

            // Generate filename
            $filename = sprintf(
                'agent_%s_%s.json',
                \Str::slug($agent['agent_name'] ?? 'unnamed'),
                now()->format('Y-m-d_His')
            );

            // Trigger download
            $this->dispatch('download-json', [
                'data' => json_encode($exportData, JSON_PRETTY_PRINT),
                'filename' => $filename,
            ]);

            $this->successMessage = 'Agent configuration exported successfully';
        } catch (\Exception $e) {
            $this->error = 'Failed to export agent: ' . $e->getMessage();
            Log::error('Agent export failed', [
                'agent_id' => $agentId,
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * Export agent in Retell.ai-compatible format.
     */
    public function exportAgentForRetell(string $agentId): void
    {
        try {
            $retellService = $this->getRetellService();
            if (! $retellService) {
                $this->error = 'Retell service not configured';

                return;
            }

            // Get agent from API
            $agent = $retellService->getAgent($agentId);
            if (! $agent) {
                $this->error = 'Agent not found';

                return;
            }

            // Don't include LLM configuration inline for Retell.ai export
            // The llm_id reference is sufficient

            // Export without AskProAI-specific metadata
            $exportData = $this->sanitizeAgentForRetellExport($agent);

            // Generate filename
            $filename = 'retell_agent_' . str_replace(' ', '_', $agent['agent_name'] ?? 'export') . '_' . date('Y-m-d_H-i-s') . '.json';

            // Dispatch download event
            $this->dispatch(
                'download-json',
                content: $exportData,
                filename: $filename
            );

            $this->successMessage = 'Agent exported in Retell.ai format';
        } catch (\Exception $e) {
            $this->error = 'Failed to export agent: ' . $e->getMessage();
            Log::error('Agent export for Retell failed', [
                'agent_id' => $agentId,
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * Import agent configuration from JSON (supports both formats).
     */
    public function importAgent(string $jsonContent): void
    {
        try {
            $retellService = $this->getRetellService();
            if (! $retellService) {
                $this->error = 'Retell service not configured';

                return;
            }

            // Parse JSON
            $agentData = json_decode($jsonContent, true);
            if (json_last_error() !== JSON_ERROR_NONE) {
                $this->error = 'Invalid JSON format: ' . json_last_error_msg();

                return;
            }

            // Detect format (AskProAI vs Retell.ai)
            $isAskProAIFormat = isset($agentData['_export_metadata']);
            $isRetellFormat = ! $isAskProAIFormat && isset($agentData['agent_id']);

            // Process based on format
            if ($isRetellFormat) {
                $agentData = $this->processRetellImport($agentData);
            } else {
                $agentData = $this->processAskProAIImport($agentData);
            }

            // Validate agent data structure
            if (! $this->validateAgentImportData($agentData)) {
                return;
            }

            // Create new agent via API
            $result = $retellService->createAgent($agentData);

            if ($result && isset($result['agent_id'])) {
                $this->successMessage = 'Agent imported successfully with ID: ' . $result['agent_id'];

                // If LLM configuration was included, create/update it
                if (isset($agentData['response_engine']['llm_configuration'])) {
                    $this->importLLMConfiguration($result['agent_id'], $agentData['response_engine']['llm_configuration']);
                }

                // Reload agents list
                $this->loadAgents();

                // Select the newly imported agent
                $this->selectAgent($result['agent_id']);
            } else {
                $this->error = 'Failed to create agent from import';
            }
        } catch (\Exception $e) {
            $this->error = 'Failed to import agent: ' . $e->getMessage();
            Log::error('Agent import failed', [
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * Process Retell.ai format import.
     */
    protected function processRetellImport(array $agentData): array
    {
        // Remove ID - will be generated new
        unset($agentData['agent_id']);

        // Add import suffix to name
        $originalName = $agentData['agent_name'] ?? 'Imported Agent';
        $agentData['agent_name'] = $originalName . ' (Import ' . date('Y-m-d H:i') . ')';

        // Handle webhook configuration if present
        if (isset($agentData['webhook_url'])) {
            // Convert to our webhook structure
            $agentData['webhook_settings'] = [
                'url' => $agentData['webhook_url'],
                'listening_events' => $agentData['listening_events'] ?? [],
            ];
            unset($agentData['webhook_url']);
            unset($agentData['listening_events']);
        }

        return $agentData;
    }

    /**
     * Process AskProAI format import.
     */
    protected function processAskProAIImport(array $agentData): array
    {
        // Remove metadata and prepare for API
        unset($agentData['_export_metadata']);
        unset($agentData['agent_id']);

        // Generate new name to avoid conflicts
        $originalName = $agentData['agent_name'] ?? 'Imported Agent';
        $agentData['agent_name'] = $originalName . ' (Import ' . date('Y-m-d H:i') . ')';

        return $agentData;
    }

    /**
     * Import LLM configuration for agent.
     */
    protected function importLLMConfiguration(string $agentId, array $llmConfig): void
    {
        try {
            $retellService = $this->getRetellService();

            // Remove ID from LLM config
            unset($llmConfig['llm_id']);

            // Create new LLM (Retell API would handle this)
            // For now, log that manual configuration is needed
            Log::info('LLM configuration needs manual setup', [
                'agent_id' => $agentId,
                'llm_config' => $llmConfig,
            ]);
        } catch (\Exception $e) {
            Log::error('Failed to import LLM configuration', [
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * Sanitize agent data for export (AskProAI format).
     */
    protected function sanitizeAgentForExport(array $agent): array
    {
        // Remove or mask sensitive fields
        $sanitized = $agent;

        // Remove internal IDs that won't be valid on import
        unset($sanitized['agent_id']);
        unset($sanitized['created_at']);
        unset($sanitized['updated_at']);

        // Remove any API keys or secrets
        if (isset($sanitized['webhook_settings'])) {
            unset($sanitized['webhook_settings']['secret']);
        }

        // Keep configuration but remove environment-specific data
        if (isset($sanitized['response_engine']['llm_id'])) {
            // Mark that LLM needs to be reconfigured on import
            $sanitized['response_engine']['_note'] = 'LLM ID will need to be updated after import';
        }

        return $sanitized;
    }

    /**
     * Sanitize agent data for Retell.ai export.
     */
    protected function sanitizeAgentForRetellExport(array $agent): array
    {
        // Complete Retell.ai agent export format based on actual export structure
        $sanitized = [];

        // Basic agent info - leave agent_id empty for import
        $sanitized['agent_id'] = '';
        $sanitized['channel'] = 'voice';
        $sanitized['last_modification_timestamp'] = time() * 1000; // milliseconds
        $sanitized['agent_name'] = $agent['agent_name'] ?? 'AskProAI Agent';

        // Response engine with LLM
        if (isset($agent['response_engine'])) {
            $sanitized['response_engine'] = [
                'type' => $agent['response_engine']['type'] ?? 'retell-llm',
                'llm_id' => $agent['response_engine']['llm_id'] ?? null,
                'version' => $agent['response_engine']['version'] ?? 1,
            ];
        } else {
            $sanitized['response_engine'] = [
                'type' => 'retell-llm',
                'llm_id' => null,
                'version' => 1,
            ];
        }

        // Webhook URL
        $sanitized['webhook_url'] = $agent['webhook_url'] ?? 'https://api.askproai.de/api/retell/webhook';

        // Language - use locale format
        $sanitized['language'] = $agent['language'] ?? 'de-DE';
        if ($sanitized['language'] === 'de') {
            $sanitized['language'] = 'de-DE';
        }

        // Privacy and call settings
        $sanitized['opt_out_sensitive_data_storage'] = isset($agent['opt_out_sensitive_data_storage']) ? (bool) $agent['opt_out_sensitive_data_storage'] : false;
        $sanitized['end_call_after_silence_ms'] = isset($agent['end_call_after_silence_ms']) ? (int) $agent['end_call_after_silence_ms'] : 50000;

        // Post call analysis data - for structured data extraction
        $sanitized['post_call_analysis_data'] = $agent['post_call_analysis_data'] ?? [
            [
                'type' => 'string',
                'name' => 'Name',
                'description' => 'Der vollständige Name des Anrufers',
            ],
            [
                'type' => 'string',
                'name' => 'Email',
                'description' => 'Die Email Adresse des Anrufers',
            ],
            [
                'type' => 'string',
                'name' => 'Telefonnummer_Anrufer',
                'description' => 'Die Telefonnummer des Anrufers',
            ],
            [
                'type' => 'string',
                'name' => 'Datum_Termin',
                'description' => 'Das Datum für den gebuchten Termin',
            ],
            [
                'type' => 'string',
                'name' => 'Uhrzeit_Termin',
                'description' => 'Die Uhrzeit wann der Termin startet',
            ],
            [
                'type' => 'string',
                'name' => 'Dienstleistung',
                'description' => 'Die gewünschte Dienstleistung',
            ],
            [
                'type' => 'string',
                'name' => 'Zusammenfassung_Anruf',
                'description' => 'Eine Zusammenfassung des Anrufs',
            ],
        ];

        // Version info
        $sanitized['version'] = isset($agent['version']) ? (int) $agent['version'] : 1;
        $sanitized['is_published'] = false;
        $sanitized['version_title'] = $agent['agent_name'] ?? 'AskProAI Agent V1';

        // Post call analysis model
        $sanitized['post_call_analysis_model'] = $agent['post_call_analysis_model'] ?? 'gpt-4o';

        // Voice settings
        $sanitized['voice_id'] = $agent['voice_id'] ?? 'elevenlabs-Matilda';
        $sanitized['voice_temperature'] = isset($agent['voice_temperature']) ? (float) $agent['voice_temperature'] : 0.2;
        $sanitized['voice_speed'] = isset($agent['voice_speed']) ? (float) $agent['voice_speed'] : 1.0;
        $sanitized['volume'] = isset($agent['volume']) ? (float) $agent['volume'] : 1.0;

        // Backchannel settings
        $sanitized['enable_backchannel'] = isset($agent['enable_backchannel']) ? (bool) $agent['enable_backchannel'] : true;
        $sanitized['backchannel_frequency'] = isset($agent['backchannel_frequency']) ? (float) $agent['backchannel_frequency'] : 0.2;
        $sanitized['backchannel_words'] = $agent['backchannel_words'] ?? [
            'mhm',
            'ach',
            'so',
            'aha',
            'okay',
            'richtig',
            'verstehe',
            'na klar',
        ];

        // Call duration and interruption
        $sanitized['max_call_duration_ms'] = isset($agent['max_call_duration_ms']) ? (int) $agent['max_call_duration_ms'] : 300000;
        $sanitized['interruption_sensitivity'] = isset($agent['interruption_sensitivity']) ? (float) $agent['interruption_sensitivity'] : 0.44;
        $sanitized['ambient_sound_volume'] = isset($agent['ambient_sound_volume']) ? (float) $agent['ambient_sound_volume'] : 0.48;
        $sanitized['responsiveness'] = isset($agent['responsiveness']) ? (float) $agent['responsiveness'] : 1.0;

        // Arrays
        $sanitized['pronunciation_dictionary'] = $agent['pronunciation_dictionary'] ?? [];
        $sanitized['normalize_for_speech'] = isset($agent['normalize_for_speech']) ? (bool) $agent['normalize_for_speech'] : true;
        $sanitized['enable_voicemail_detection'] = isset($agent['enable_voicemail_detection']) ? (bool) $agent['enable_voicemail_detection'] : false;
        $sanitized['user_dtmf_options'] = $agent['user_dtmf_options'] ?? (object) [];

        // LLM Data - this is critical for the agent to work
        if (isset($agent['retellLlmData'])) {
            $sanitized['retellLlmData'] = $agent['retellLlmData'];
        } else {
            // Try to fetch LLM data if we have llm_id
            if (isset($sanitized['response_engine']['llm_id']) && $sanitized['response_engine']['llm_id']) {
                try {
                    $retellService = $this->getRetellService();
                    if ($retellService) {
                        $llmData = $retellService->getRetellLLM($sanitized['response_engine']['llm_id']);
                        if ($llmData) {
                            $sanitized['retellLlmData'] = [
                                'llm_id' => $llmData['llm_id'] ?? $sanitized['response_engine']['llm_id'],
                                'version' => $llmData['version'] ?? 1,
                                'model' => $llmData['model'] ?? 'gpt-4',
                                'model_temperature' => $llmData['model_temperature'] ?? 0.04,
                                'model_high_priority' => $llmData['model_high_priority'] ?? true,
                                'tool_call_strict_mode' => $llmData['tool_call_strict_mode'] ?? false,
                                'general_prompt' => $llmData['general_prompt'] ?? '',
                                'general_tools' => $llmData['general_tools'] ?? [],
                                'begin_message' => $llmData['begin_message'] ?? '',
                                'knowledge_base_ids' => $llmData['knowledge_base_ids'] ?? [],
                                'last_modification_timestamp' => $llmData['last_modification_timestamp'] ?? time() * 1000,
                                'is_published' => false,
                            ];
                        }
                    }
                } catch (\Exception $e) {
                    Log::warning('Could not fetch LLM data for export', ['error' => $e->getMessage()]);
                }
            }

            // If still no LLM data, provide minimal structure
            if (! isset($sanitized['retellLlmData'])) {
                $sanitized['retellLlmData'] = [
                    'llm_id' => $sanitized['response_engine']['llm_id'],
                    'version' => 1,
                    'model' => 'gpt-4',
                    'model_temperature' => 0.04,
                    'model_high_priority' => true,
                    'tool_call_strict_mode' => false,
                    'general_prompt' => '',
                    'general_tools' => [],
                    'begin_message' => '',
                    'knowledge_base_ids' => [],
                    'last_modification_timestamp' => time() * 1000,
                    'is_published' => false,
                ];
            }
        }

        // Optional fields
        $sanitized['conversationFlow'] = null;
        $sanitized['llmURL'] = null;

        return $sanitized;
    }

    /**
     * Validate agent import data.
     */
    protected function validateAgentImportData(array $data): bool
    {
        // Check required fields
        $requiredFields = ['agent_name', 'voice_id', 'response_engine'];
        foreach ($requiredFields as $field) {
            if (! isset($data[$field])) {
                $this->error = "Missing required field: {$field}";

                return false;
            }
        }

        // Validate response engine
        if (! isset($data['response_engine']['type'])) {
            $this->error = 'Invalid response engine configuration';

            return false;
        }

        // Check for valid voice ID - expanded list for Retell.ai compatibility
        $validVoices = [
            // OpenAI voices
            'openai-Alloy', 'openai-Echo', 'openai-Fable', 'openai-Onyx',
            'openai-Nova', 'openai-Shimmer',
            // ElevenLabs voices (German optimized)
            'elevenlabs-Matilda', 'elevenlabs-Wilhelm', 'elevenlabs-Dorothy',
            'elevenlabs-Thomas', 'elevenlabs-Charlie', 'elevenlabs-George',
            'elevenlabs-Emily', 'elevenlabs-Chris', 'elevenlabs-Brian',
            'elevenlabs-Daniel', 'elevenlabs-Lily', 'elevenlabs-Bill',
            // Deepgram voices
            'deepgram-Asteria', 'deepgram-Luna', 'deepgram-Stella',
            'deepgram-Athena', 'deepgram-Hera', 'deepgram-Orion',
            'deepgram-Perseus', 'deepgram-Angus', 'deepgram-Orpheus',
            'deepgram-Helios', 'deepgram-Zeus',
        ];

        // Allow any voice ID starting with known providers for future compatibility
        $validProviders = ['openai-', 'elevenlabs-', 'deepgram-', 'cartesia-'];
        $isValidProvider = false;
        foreach ($validProviders as $provider) {
            if (str_starts_with($data['voice_id'], $provider)) {
                $isValidProvider = true;

                break;
            }
        }

        if (! $isValidProvider && ! in_array($data['voice_id'], $validVoices)) {
            // Log warning but don't fail - Retell.ai might have new voices
            Log::warning('Unknown voice ID used', ['voice_id' => $data['voice_id']]);
        }

        return true;
    }

    /**
     * Handle file upload for agent import.
     */
    public function updatedAgentImportFile(): void
    {
        try {
            if (! $this->agentImportFile) {
                $this->error = 'No file uploaded';

                return;
            }

            // Validate file
            $this->validate([
                'agentImportFile' => 'required|file|mimes:json|max:2048', // 2MB max
            ]);

            // Read file content
            $content = $this->agentImportFile->get();

            // Import the agent
            $this->importAgent($content);

            // Clear the file input
            $this->agentImportFile = null;
        } catch (\Exception $e) {
            $this->error = 'Failed to process uploaded file: ' . $e->getMessage();
            Log::error('Agent import upload failed', [
                'error' => $e->getMessage(),
            ]);

            // Clear the file input
            $this->agentImportFile = null;
        }
    }

    /**
     * Save full agent configuration including all settings.
     */
    public function saveAgentFull(): void
    {
        try {
            $this->isLoading = true;
            $this->error = null;

            // Validate that we have agent data
            if (empty($this->editingAgentFull['agent_id'])) {
                $this->error = 'No agent selected for editing';
                $this->isLoading = false;

                return;
            }

            $agentId = $this->editingAgentFull['agent_id'];

            // Get Retell service
            $retellService = $this->getRetellService();
            if (! $retellService) {
                $this->error = 'Retell service not configured';
                $this->isLoading = false;

                return;
            }

            // Prepare agent update data
            $agentUpdateData = [
                'agent_name' => $this->editingAgentFull['agent_name'] ?? '',
                'voice_id' => $this->editingAgentFull['voice_id'] ?? 'openai-Alloy',
                'voice_speed' => $this->editingAgentFull['voice_speed'] ?? 1.0,
                'voice_temperature' => $this->editingAgentFull['voice_temperature'] ?? 0.0,
                'language' => $this->editingAgentFull['language'] ?? 'en-US',
                'interruption_sensitivity' => $this->editingAgentFull['interruption_sensitivity'] ?? 1,
                'responsiveness' => $this->editingAgentFull['responsiveness'] ?? 1,
                'enable_backchannel' => $this->editingAgentFull['enable_backchannel'] ?? true,
                'backchannel_frequency' => $this->editingAgentFull['backchannel_frequency'] ?? 0.8,
                'backchannel_words' => $this->editingAgentFull['backchannel_words'] ?? ['yeah', 'uh-huh', 'hmm', 'got it', 'right'],
                'reminder_trigger_ms' => $this->editingAgentFull['reminder_trigger_ms'] ?? 10000,
                'reminder_max_count' => $this->editingAgentFull['reminder_max_count'] ?? 1,
                'ambient_sound' => $this->editingAgentFull['ambient_sound'] ?? null,
                'ambient_sound_volume' => $this->editingAgentFull['ambient_sound_volume'] ?? 1.0,
                'pronunciation_dictionary' => $this->editingAgentFull['pronunciation_dictionary'] ?? [],
                'normalize_for_speech' => $this->editingAgentFull['normalize_for_speech'] ?? true,
                'end_call_after_silence_ms' => $this->editingAgentFull['end_call_after_silence_ms'] ?? 600000,
                'max_call_duration_ms' => $this->editingAgentFull['max_call_duration_ms'] ?? 3600000,
                'voicemail_detection_timeout_ms' => $this->editingAgentFull['voicemail_detection_timeout_ms'] ?? 30000,
                'voicemail_message' => $this->editingAgentFull['voicemail_message'] ?? null,
                'opt_out_sensitive_data_storage' => $this->editingAgentFull['opt_out_sensitive_data_storage'] ?? false,
                'fallback_voice_ids' => $this->editingAgentFull['fallback_voice_ids'] ?? [],
            ];

            // Add post-call analysis fields if present
            if (! empty($this->editingPostCallAnalysis)) {
                $agentUpdateData['post_call_analysis_data'] = $this->editingPostCallAnalysis;
            }

            // Add webhook URL if present
            if (! empty($this->editingWebhookSettings['url'])) {
                $agentUpdateData['webhook_url'] = $this->editingWebhookSettings['url'];
            }

            // Update agent via API
            $agentResult = $retellService->updateAgent($agentId, $agentUpdateData);

            if (! $agentResult) {
                $this->error = 'Failed to update agent configuration';
                $this->isLoading = false;

                return;
            }

            // If agent uses retell-llm, update LLM settings
            if (isset($this->editingAgentFull['response_engine']['type']) &&
                $this->editingAgentFull['response_engine']['type'] === 'retell-llm' &&
                isset($this->editingAgentFull['response_engine']['llm_id'])) {
                $llmId = $this->editingAgentFull['response_engine']['llm_id'];

                // Prepare LLM update data
                $llmUpdateData = [
                    'model' => $this->editingLLM['model'] ?? 'gpt-4-turbo',
                    'temperature' => $this->editingLLM['temperature'] ?? 0.7,
                    'max_tokens' => $this->editingLLM['max_tokens'] ?? 200,
                    'general_prompt' => $this->editingLLM['general_prompt'] ?? '',
                    'general_tools' => $this->editingFunctions ?? [],
                    'states' => $this->editingLLM['states'] ?? [],
                ];

                // Add other LLM settings if present
                if (isset($this->editingLLM['top_p'])) {
                    $llmUpdateData['top_p'] = $this->editingLLM['top_p'];
                }
                if (isset($this->editingLLM['frequency_penalty'])) {
                    $llmUpdateData['frequency_penalty'] = $this->editingLLM['frequency_penalty'];
                }
                if (isset($this->editingLLM['presence_penalty'])) {
                    $llmUpdateData['presence_penalty'] = $this->editingLLM['presence_penalty'];
                }
                if (isset($this->editingLLM['begin_message'])) {
                    $llmUpdateData['begin_message'] = $this->editingLLM['begin_message'];
                }
                if (isset($this->editingLLM['inbound_dynamic_variables_webhook_url'])) {
                    $llmUpdateData['inbound_dynamic_variables_webhook_url'] = $this->editingLLM['inbound_dynamic_variables_webhook_url'];
                }

                // Update LLM via API
                $llmResult = $retellService->updateRetellLLM($llmId, $llmUpdateData);

                if (! $llmResult) {
                    $this->error = 'Agent updated but failed to update LLM configuration';
                    $this->isLoading = false;

                    return;
                }
            }

            $this->successMessage = 'Agent configuration saved successfully';

            // Update local state
            $this->agents = collect($this->agents)->map(function ($agent) use ($agentId, $agentResult) {
                if ($agent['agent_id'] === $agentId) {
                    return array_merge($agent, $agentResult);
                }

                return $agent;
            })->toArray();

            // Clear caches
            Cache::forget('retell_agents_' . auth()->id());
            if (isset($llmId)) {
                Cache::forget("retell_llm_data_{$llmId}");
                Cache::forget("retell_llm_functions_{$llmId}");
            }

            $this->isLoading = false;

            // Show success notification
            $this->dispatch('show-notification', [
                'message' => 'Agent configuration updated successfully',
                'type' => 'success',
                'duration' => 3000,
            ]);
        } catch (\Exception $e) {
            $this->error = 'Failed to save agent configuration: ' . $e->getMessage();
            $this->isLoading = false;
            Log::error('Failed to save full agent configuration', [
                'agent_id' => $this->editingAgentFull['agent_id'] ?? null,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
        }
    }
    
    /**
     * Extract agent fields from flat API configuration structure
     * Since we now store raw API data, we only need to handle flat structure
     */
    protected function extractAgentFields(array $config): array
    {
        // Since we now store raw API data, we only need to handle flat structure
        // Return the config as-is - it's already in the correct format from Retell API
        return $config;
    }
}
            $fields['enable_backchannel'] = $config['conversation_settings']['enable_backchannel'] ?? true;
            $fields['interruption_sensitivity'] = $config['conversation_settings']['interruption_sensitivity'] ?? 1;
            $fields['responsiveness'] = $config['conversation_settings']['responsiveness'] ?? 1;
            $fields['boosted_keywords'] = $config['conversation_settings']['boosted_keywords'] ?? [];
            $fields['reminder_trigger_ms'] = $config['conversation_settings']['reminder_trigger_ms'] ?? 10000;
            $fields['reminder_max_count'] = $config['conversation_settings']['reminder_max_count'] ?? 1;
            $fields['normalize_for_speech'] = $config['conversation_settings']['normalize_for_speech'] ?? true;
            $fields['pronunciation_guide'] = $config['conversation_settings']['pronunciation_guide'] ?? [];
            $fields['opt_out_sensitive_data_storage'] = $config['conversation_settings']['opt_out_sensitive_data_storage'] ?? false;
        } else {
            // Flat structure (backward compatibility)
            $fields['language'] = $config['language'] ?? 'en-US';
            $fields['enable_backchannel'] = $config['enable_backchannel'] ?? true;
            $fields['interruption_sensitivity'] = $config['interruption_sensitivity'] ?? 1;
            $fields['responsiveness'] = $config['responsiveness'] ?? 1;
            $fields['boosted_keywords'] = $config['boosted_keywords'] ?? [];
            $fields['reminder_trigger_ms'] = $config['reminder_trigger_ms'] ?? 10000;
            $fields['reminder_max_count'] = $config['reminder_max_count'] ?? 1;
            $fields['normalize_for_speech'] = $config['normalize_for_speech'] ?? true;
            $fields['pronunciation_guide'] = $config['pronunciation_guide'] ?? [];
            $fields['opt_out_sensitive_data_storage'] = $config['opt_out_sensitive_data_storage'] ?? false;
        }
        
        // Extract audio-related fields
        if (isset($config['audio_settings'])) {
            // Nested structure
            $fields['ambient_sound'] = $config['audio_settings']['ambient_sound'] ?? null;
            $fields['ambient_sound_volume'] = $config['audio_settings']['ambient_sound_volume'] ?? 0.5;
            $fields['backchannel_frequency'] = $config['audio_settings']['backchannel_frequency'] ?? 0.8;
            $fields['backchannel_words'] = $config['audio_settings']['backchannel_words'] ?? [];
        } else {
            // Flat structure (backward compatibility)
            // The API doesn't return ambient_sound directly, it's always null
            $fields['ambient_sound'] = null;
            $fields['ambient_sound_volume'] = $config['ambient_sound_volume'] ?? 0.5;
            $fields['backchannel_frequency'] = $config['backchannel_frequency'] ?? 0.8;
            $fields['backchannel_words'] = $config['backchannel_words'] ?? [];
        }
        
        // Extract end call settings
        if (isset($config['end_call_settings'])) {
            // Nested structure
            $fields['end_call_after_silence_ms'] = $config['end_call_settings']['end_call_after_silence_ms'] ?? 30000;
            $fields['max_call_duration_ms'] = $config['end_call_settings']['max_call_duration_ms'] ?? 3600000;
            $fields['end_call_phrases'] = $config['end_call_settings']['end_call_phrases'] ?? [];
        } else {
            // Flat structure (backward compatibility)
            $fields['end_call_after_silence_ms'] = $config['end_call_after_silence_ms'] ?? 30000;
            $fields['max_call_duration_ms'] = $config['max_call_duration_ms'] ?? 3600000;
            $fields['end_call_phrases'] = $config['end_call_phrases'] ?? [];
        }
        
        // Extract voicemail settings
        if (isset($config['voicemail_settings'])) {
            // Nested structure
            $fields['enable_voicemail_detection'] = $config['voicemail_settings']['enable_voicemail_detection'] ?? false;
            $fields['voicemail_message'] = $config['voicemail_settings']['voicemail_message'] ?? '';
            $fields['voicemail_detection_timeout_ms'] = $config['voicemail_settings']['voicemail_detection_timeout_ms'] ?? 5000;
        } else {
            // Flat structure (backward compatibility)
            $fields['enable_voicemail_detection'] = $config['enable_voicemail_detection'] ?? false;
            // These fields might not be in the API response, provide defaults
            $fields['voicemail_message'] = '';
            $fields['voicemail_detection_timeout_ms'] = 5000;
        }
        
        // Extract webhook settings
        if (isset($config['webhook_settings'])) {
            // Nested structure
            $fields['webhook_url'] = $config['webhook_settings']['webhook_url'] ?? '';
            $fields['enable_webhook_for_analysis'] = $config['webhook_settings']['enable_webhook_for_analysis'] ?? true;
            $fields['enable_webhook_for_transcripts'] = $config['webhook_settings']['enable_webhook_for_transcripts'] ?? true;
        } else {
            // Flat structure (backward compatibility)
            $fields['webhook_url'] = $config['webhook_url'] ?? '';
            $fields['enable_webhook_for_analysis'] = $config['enable_webhook_for_analysis'] ?? true;
            $fields['enable_webhook_for_transcripts'] = $config['enable_webhook_for_transcripts'] ?? true;
        }
        
        // Extract other top-level fields
        $fields['agent_id'] = $config['agent_id'] ?? '';
        $fields['agent_name'] = $config['agent_name'] ?? '';
        $fields['response_engine'] = $config['response_engine'] ?? [];
        $fields['status'] = $config['status'] ?? 'inactive';
        $fields['begin_message'] = $config['begin_message'] ?? '';
        $fields['general_prompt'] = $config['general_prompt'] ?? '';
        $fields['general_tools'] = $config['general_tools'] ?? [];
        $fields['states'] = $config['states'] ?? [];
        
        // Extract version information
        $fields['version'] = $config['version'] ?? null;
        $fields['version_title'] = $config['version_title'] ?? null;
        $fields['is_published'] = $config['is_published'] ?? false;
        $fields['last_modification_timestamp'] = $config['last_modification_timestamp'] ?? null;
        
        // Extract other missing fields
        $fields['post_call_analysis_data'] = $config['post_call_analysis_data'] ?? [];
        $fields['post_call_analysis_model'] = $config['post_call_analysis_model'] ?? '';
        $fields['voice_model'] = $config['voice_model'] ?? '';
        $fields['volume'] = $config['volume'] ?? 1.0;
        $fields['backchannel_frequency'] = $config['backchannel_frequency'] ?? 0.8;
        $fields['backchannel_words'] = $config['backchannel_words'] ?? [];
        $fields['pronunciation_dictionary'] = $config['pronunciation_dictionary'] ?? [];
        $fields['user_dtmf_options'] = $config['user_dtmf_options'] ?? [];
        $fields['denoising_mode'] = $config['denoising_mode'] ?? '';
        
        return $fields;
    }
}
