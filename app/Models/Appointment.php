<?php

namespace App\Models;

use App\Traits\BelongsToCompany;
use App\Traits\OptimizedAppointmentQueries;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Appointment extends Model
{
    use HasFactory, SoftDeletes, BelongsToCompany, OptimizedAppointmentQueries;

    /**
     * Mass Assignment Protection
     *
     * SECURITY: Protects against VULN-009 - Mass Assignment vulnerability
     * Tenant isolation and financial fields must never be mass-assigned
     */
    protected $guarded = [
        'id',                    // Primary key

        // Multi-tenant isolation (CRITICAL)
        'company_id',            // Must be set only via service/customer relationship
        'branch_id',             // Must be set only via service/customer relationship

        // Financial data (CRITICAL)
        'price',                 // Calculated from service
        'total_price',           // Calculated field

        // Locking mechanism (CRITICAL)
        'lock_token',            // Generated by locking system
        'lock_expires_at',       // Set by locking system
        'version',               // Optimistic locking counter

        // System notification timestamps
        'reminder_24h_sent_at',  // Set by notification system

        // System timestamps
        'created_at',
        'updated_at',
        'deleted_at',
    ];

    protected $casts = [
        'metadata' => 'array',
        'is_recurring' => 'boolean',
        'recurring_pattern' => 'array',
        // 'price' => 'decimal:2',  // ❌ REMOVED: appointments table has no price column (price comes from service)
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        // Composite casts
        'is_composite' => 'boolean',
        'segments' => 'array',
        'starts_at' => 'datetime',
        'ends_at' => 'datetime',
        // Sync orchestration casts (Phase 2: Bidirectional Cal.com Sync)
        'sync_initiated_at' => 'datetime',
        'manual_review_flagged_at' => 'datetime',
        'requires_manual_review' => 'boolean',
    ];

    /**
     * Boot the model - Multi-tenant isolation validation
     *
     * CRITICAL: Ensures all appointments have valid branch_id for:
     * - Multi-tenant isolation (company_id alone is insufficient)
     * - Cal.com sync context (branch determines staff assignment)
     * - Data integrity (prevents partial records)
     */
    protected static function boot()
    {
        parent::boot();

        static::creating(function ($appointment) {
            // ═══════════════════════════════════════════════════════════
            // CRITICAL: branch_id MUST NOT be NULL
            // ═══════════════════════════════════════════════════════════
            if (is_null($appointment->branch_id)) {
                throw new \Exception(
                    'CRITICAL: Appointments must have a branch_id. ' .
                    'This is a multi-tenant isolation requirement. ' .
                    'Ensure createAppointment() passes branch_id parameter.'
                );
            }

            // ═══════════════════════════════════════════════════════════
            // SECURITY: Validate branch belongs to company
            // ═══════════════════════════════════════════════════════════
            if ($appointment->company_id && $appointment->branch_id) {
                $branchBelongsToCompany = Branch::where('id', $appointment->branch_id)
                    ->where('company_id', $appointment->company_id)
                    ->exists();

                if (!$branchBelongsToCompany) {
                    throw new \Exception(
                        "SECURITY VIOLATION: Branch {$appointment->branch_id} " .
                        "does not belong to company {$appointment->company_id}. " .
                        'Tenant isolation violated.'
                    );
                }
            }
        });
    }

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class);
    }

    public function staff(): BelongsTo
    {
        return $this->belongsTo(Staff::class);
    }

    public function branch(): BelongsTo
    {
        return $this->belongsTo(Branch::class);
    }

    public function service(): BelongsTo
    {
        return $this->belongsTo(Service::class);
    }

    /**
     * Processing Time phases for this appointment
     * Returns phases in chronological order (initial → processing → final)
     */
    public function phases(): HasMany
    {
        return $this->hasMany(AppointmentPhase::class);
    }

    /**
     * Call that originated this appointment
     */
    public function call(): BelongsTo
    {
        return $this->belongsTo(Call::class, 'call_id');
    }

    /**
     * Cal.com host mapping for this appointment (Phase 2: Staff Assignment)
     */
    public function calcomHostMapping(): BelongsTo
    {
        return $this->belongsTo(CalcomHostMapping::class, 'calcom_host_id', 'calcom_host_id');
    }

    /**
     * User who initiated the sync to Cal.com (Phase 2: Bidirectional Sync)
     * NULL for system/phone-initiated syncs
     */
    public function syncInitiatedByUser(): BelongsTo
    {
        return $this->belongsTo(User::class, 'sync_initiated_by_user_id');
    }

    /**
     * Check if appointment is composite
     */
    public function isComposite(): bool
    {
        return $this->is_composite === true;
    }

    /**
     * Get segments for composite appointment
     */
    public function getSegments(): array
    {
        return $this->segments ?? [];
    }

    /**
     * Scope for composite appointments
     */
    public function scopeComposite($query)
    {
        return $query->where('is_composite', true);
    }

    /**
     * Scope for simple appointments
     */
    public function scopeSimple($query)
    {
        return $query->where('is_composite', false);
    }

    /**
     * Related appointments in same composite group
     */
    public function compositeGroup()
    {
        if (!$this->composite_group_uid) {
            return collect();
        }
        return static::where('composite_group_uid', $this->composite_group_uid)
            ->orderBy('starts_at')
            ->get();
    }

    /**
     * Parent appointment for recurring series
     */
    public function parentAppointment(): BelongsTo
    {
        return $this->belongsTo(Appointment::class, 'parent_appointment_id');
    }

    /**
     * Child appointments for recurring series
     */
    public function children(): HasMany
    {
        return $this->hasMany(Appointment::class, 'parent_appointment_id');
    }

    /**
     * Recurring pattern configuration
     */
    public function recurringPattern(): HasOne
    {
        return $this->hasOne(RecurringAppointmentPattern::class);
    }

    /**
     * Get all modifications (history) for this appointment
     * Used for policy enforcement and customer engagement scoring
     */
    public function modifications(): HasMany
    {
        return $this->hasMany(AppointmentModification::class);
    }

    /**
     * Check if this is part of a recurring series
     */
    public function isPartOfRecurringSeries(): bool
    {
        return $this->is_recurring || $this->parent_appointment_id !== null;
    }

    /**
     * Get the root parent of recurring series
     */
    public function getRootParent(): ?Appointment
    {
        if ($this->parent_appointment_id) {
            return $this->parentAppointment;
        }
        if ($this->is_recurring) {
            return $this;
        }
        return null;
    }

    /**
     * Scope for recurring appointments
     */
    public function scopeRecurring($query)
    {
        return $query->where('is_recurring', true);
    }

    /**
     * Scope for non-recurring appointments
     */
    public function scopeNonRecurring($query)
    {
        return $query->where('is_recurring', false)
            ->whereNull('parent_appointment_id');
    }

    /**
     * PHASE 2: Scope - Find by idempotency key
     * Used for deduplicating retried booking requests
     */
    public function scopeByIdempotencyKey($query, string $key)
    {
        return $query->where('idempotency_key', $key);
    }

    /**
     * PHASE 2: Scope - Find duplicate booking in time window
     * Prevents double bookings for same customer/service/time
     *
     * USAGE:
     * ```php
     * $duplicate = Appointment::findDuplicate(
     *     customerId: 123,
     *     serviceId: 456,
     *     startsAt: '2025-10-20 14:00:00',
     *     windowMinutes: 5  // within 5min window
     * );
     * ```
     */
    public function scopeFindDuplicate($query, int $customerId, int $serviceId, string $startsAt, int $windowMinutes = 5)
    {
        $startTime = \Carbon\Carbon::parse($startsAt);

        return $query
            ->where('customer_id', $customerId)
            ->where('service_id', $serviceId)
            ->whereBetween('starts_at', [
                $startTime->copy()->subMinutes($windowMinutes),
                $startTime->copy()->addMinutes($windowMinutes),
            ])
            ->whereIn('status', ['scheduled', 'confirmed', 'pending'])
            ->orderBy('created_at', 'desc');
    }

    /*
    |--------------------------------------------------------------------------
    | Accessors for Livewire Serialization (2025-10-22)
    |--------------------------------------------------------------------------
    | These accessors replace closures in RelationManagers to fix Livewire
    | serialization issues. Closures are not JSON-serializable and cause
    | "Snapshot missing on Livewire component" errors.
    */

    /**
     * Get appointment duration in minutes
     *
     * @return int|null
     */
    public function getDurationMinutesAttribute(): ?int
    {
        if (!$this->starts_at || !$this->ends_at) {
            return null;
        }

        return \Carbon\Carbon::parse($this->starts_at)->diffInMinutes($this->ends_at);
    }

    /**
     * Get formatted duration string
     *
     * @return string|null
     */
    public function getDurationFormattedAttribute(): ?string
    {
        $duration = $this->duration_minutes;

        return $duration ? "{$duration} Min." : null;
    }
}