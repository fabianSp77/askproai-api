<?php

namespace App\Models;

use App\Traits\BelongsToCompany;
use App\Traits\OptimizedAppointmentQueries;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Appointment extends Model
{
    use HasFactory, SoftDeletes, BelongsToCompany, OptimizedAppointmentQueries;

    /**
     * Mass Assignment Protection
     *
     * SECURITY: Protects against VULN-009 - Mass Assignment vulnerability
     * Tenant isolation and financial fields must never be mass-assigned
     */
    protected $guarded = [
        'id',                    // Primary key

        // Multi-tenant isolation (CRITICAL)
        'company_id',            // Must be set only via service/customer relationship
        'branch_id',             // Must be set only via service/customer relationship

        // Financial data (CRITICAL)
        'price',                 // Calculated from service
        'total_price',           // Calculated field

        // Locking mechanism (CRITICAL)
        'lock_token',            // Generated by locking system
        'lock_expires_at',       // Set by locking system
        'version',               // Optimistic locking counter

        // System notification timestamps
        'reminder_24h_sent_at',  // Set by notification system

        // Customer Portal audit trail (CRITICAL)
        'last_modified_at',      // Set by optimistic locking system
        'last_modified_by',      // Set by optimistic locking system

        // System timestamps
        'created_at',
        'updated_at',
        'deleted_at',
    ];

    protected $casts = [
        'metadata' => 'array',
        'is_recurring' => 'boolean',
        'recurring_pattern' => 'array',
        // 'price' => 'decimal:2',  // ❌ REMOVED: appointments table has no price column (price comes from service)
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        // Composite casts
        'is_composite' => 'boolean',
        'segments' => 'array',
        'starts_at' => 'datetime',
        'ends_at' => 'datetime',
        // Sync orchestration casts (Phase 2: Bidirectional Cal.com Sync)
        'sync_initiated_at' => 'datetime',
        'manual_review_flagged_at' => 'datetime',
        'requires_manual_review' => 'boolean',
        // Customer Portal: Optimistic locking & audit trail
        'last_modified_at' => 'datetime',
        'last_modified_by' => 'integer',
        // Customer Portal: Cal.com sync status tracking
        'calcom_sync_attempts' => 'integer',
        'calcom_last_sync_at' => 'datetime',
        // Reschedule tracking (2025-11-25)
        'rescheduled_at' => 'datetime',
        'rescheduled_count' => 'integer',
        'previous_starts_at' => 'datetime',
    ];

    /**
     * Boot the model - Multi-tenant isolation validation
     *
     * CRITICAL: Ensures all appointments have valid branch_id for:
     * - Multi-tenant isolation (company_id alone is insufficient)
     * - Cal.com sync context (branch determines staff assignment)
     * - Data integrity (prevents partial records)
     */
    protected static function boot()
    {
        parent::boot();

        static::creating(function ($appointment) {
            // ═══════════════════════════════════════════════════════════
            // CRITICAL: branch_id MUST NOT be NULL
            // ═══════════════════════════════════════════════════════════
            if (is_null($appointment->branch_id)) {
                throw new \Exception(
                    'CRITICAL: Appointments must have a branch_id. ' .
                    'This is a multi-tenant isolation requirement. ' .
                    'Ensure createAppointment() passes branch_id parameter.'
                );
            }

            // ═══════════════════════════════════════════════════════════
            // SECURITY: Validate branch belongs to company
            // ═══════════════════════════════════════════════════════════
            if ($appointment->company_id && $appointment->branch_id) {
                $branchBelongsToCompany = Branch::where('id', $appointment->branch_id)
                    ->where('company_id', $appointment->company_id)
                    ->exists();

                if (!$branchBelongsToCompany) {
                    throw new \Exception(
                        "SECURITY VIOLATION: Branch {$appointment->branch_id} " .
                        "does not belong to company {$appointment->company_id}. " .
                        'Tenant isolation violated.'
                    );
                }
            }
        });
    }

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class);
    }

    public function staff(): BelongsTo
    {
        return $this->belongsTo(Staff::class);
    }

    public function branch(): BelongsTo
    {
        return $this->belongsTo(Branch::class);
    }

    public function service(): BelongsTo
    {
        return $this->belongsTo(Service::class);
    }

    /**
     * Processing Time phases for this appointment
     * Returns phases in chronological order (initial → processing → final)
     */
    public function phases(): HasMany
    {
        return $this->hasMany(AppointmentPhase::class);
    }

    /**
     * Call that originated this appointment
     */
    public function call(): BelongsTo
    {
        return $this->belongsTo(Call::class, 'call_id');
    }

    /**
     * Cal.com host mapping for this appointment (Phase 2: Staff Assignment)
     */
    public function calcomHostMapping(): BelongsTo
    {
        return $this->belongsTo(CalcomHostMapping::class, 'calcom_host_id', 'calcom_host_id');
    }

    /**
     * User who initiated the sync to Cal.com (Phase 2: Bidirectional Sync)
     * NULL for system/phone-initiated syncs
     */
    public function syncInitiatedByUser(): BelongsTo
    {
        return $this->belongsTo(User::class, 'sync_initiated_by_user_id');
    }

    /**
     * User who last modified this appointment (Customer Portal)
     * Used for optimistic locking audit trail
     */
    public function lastModifiedBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'last_modified_by');
    }

    /**
     * Audit logs for this appointment (Customer Portal)
     * Immutable history of all changes (created, rescheduled, cancelled)
     */
    public function auditLogs(): HasMany
    {
        return $this->hasMany(AppointmentAuditLog::class);
    }

    /**
     * Check if appointment is composite
     */
    public function isComposite(): bool
    {
        return $this->is_composite === true;
    }

    /**
     * Get segments for composite appointment
     */
    public function getSegments(): array
    {
        return $this->segments ?? [];
    }

    /**
     * Scope for composite appointments
     */
    public function scopeComposite($query)
    {
        return $query->where('is_composite', true);
    }

    /**
     * Scope for simple appointments
     */
    public function scopeSimple($query)
    {
        return $query->where('is_composite', false);
    }

    /**
     * Related appointments in same composite group
     */
    public function compositeGroup()
    {
        if (!$this->composite_group_uid) {
            return collect();
        }
        return static::where('composite_group_uid', $this->composite_group_uid)
            ->orderBy('starts_at')
            ->get();
    }

    /**
     * Parent appointment for recurring series
     */
    public function parentAppointment(): BelongsTo
    {
        return $this->belongsTo(Appointment::class, 'parent_appointment_id');
    }

    /**
     * Child appointments for recurring series
     */
    public function children(): HasMany
    {
        return $this->hasMany(Appointment::class, 'parent_appointment_id');
    }

    /**
     * Recurring pattern configuration
     */
    public function recurringPattern(): HasOne
    {
        return $this->hasOne(RecurringAppointmentPattern::class);
    }

    /**
     * Get all modifications (history) for this appointment
     * Used for policy enforcement and customer engagement scoring
     */
    public function modifications(): HasMany
    {
        return $this->hasMany(AppointmentModification::class);
    }

    /**
     * Check if this is part of a recurring series
     */
    public function isPartOfRecurringSeries(): bool
    {
        return $this->is_recurring || $this->parent_appointment_id !== null;
    }

    /**
     * Get the root parent of recurring series
     */
    public function getRootParent(): ?Appointment
    {
        if ($this->parent_appointment_id) {
            return $this->parentAppointment;
        }
        if ($this->is_recurring) {
            return $this;
        }
        return null;
    }

    /**
     * Scope for recurring appointments
     */
    public function scopeRecurring($query)
    {
        return $query->where('is_recurring', true);
    }

    /**
     * Scope for non-recurring appointments
     */
    public function scopeNonRecurring($query)
    {
        return $query->where('is_recurring', false)
            ->whereNull('parent_appointment_id');
    }

    /**
     * PHASE 2: Scope - Find by idempotency key
     * Used for deduplicating retried booking requests
     */
    public function scopeByIdempotencyKey($query, string $key)
    {
        return $query->where('idempotency_key', $key);
    }

    /**
     * PHASE 2: Scope - Find duplicate booking in time window
     * Prevents double bookings for same customer/service/time
     *
     * USAGE:
     * ```php
     * $duplicate = Appointment::findDuplicate(
     *     customerId: 123,
     *     serviceId: 456,
     *     startsAt: '2025-10-20 14:00:00',
     *     windowMinutes: 5  // within 5min window
     * );
     * ```
     */
    public function scopeFindDuplicate($query, int $customerId, int $serviceId, string $startsAt, int $windowMinutes = 5)
    {
        $startTime = \Carbon\Carbon::parse($startsAt);

        return $query
            ->where('customer_id', $customerId)
            ->where('service_id', $serviceId)
            ->whereBetween('starts_at', [
                $startTime->copy()->subMinutes($windowMinutes),
                $startTime->copy()->addMinutes($windowMinutes),
            ])
            ->whereIn('status', ['scheduled', 'confirmed', 'pending'])
            ->orderBy('created_at', 'desc');
    }

    /*
    |--------------------------------------------------------------------------
    | Accessors for Livewire Serialization (2025-10-22)
    |--------------------------------------------------------------------------
    | These accessors replace closures in RelationManagers to fix Livewire
    | serialization issues. Closures are not JSON-serializable and cause
    | "Snapshot missing on Livewire component" errors.
    */

    /**
     * Get appointment duration in minutes
     *
     * @return int|null
     */
    public function getDurationMinutesAttribute(): ?int
    {
        if (!$this->starts_at || !$this->ends_at) {
            return null;
        }

        return \Carbon\Carbon::parse($this->starts_at)->diffInMinutes($this->ends_at);
    }

    /**
     * Get formatted duration string
     *
     * @return string|null
     */
    public function getDurationFormattedAttribute(): ?string
    {
        $duration = $this->duration_minutes;

        return $duration ? "{$duration} Min." : null;
    }

    /*
    |--------------------------------------------------------------------------
    | Cancellation Helper Methods (2025-11-20)
    |--------------------------------------------------------------------------
    | Methods to support cancelled appointment display in Filament admin panel
    */

    /**
     * Check if appointment was cancelled
     *
     * @return bool
     */
    public function isCancelled(): bool
    {
        return $this->status === 'cancelled';
    }

    /**
     * Check if appointment was rescheduled
     *
     * @return bool
     */
    public function wasRescheduled(): bool
    {
        return $this->rescheduled_at !== null || $this->rescheduled_count > 0;
    }

    /**
     * Get the latest reschedule modification record
     *
     * @return \App\Models\AppointmentModification|null
     */
    public function getLastRescheduleRecord(): ?AppointmentModification
    {
        return $this->modifications()
            ->where('modification_type', 'reschedule')
            ->latest('created_at')
            ->first();
    }

    /**
     * Get the display badge for appointment status
     *
     * Returns the appropriate badge text for Admin Portal:
     * - "Verschoben" if rescheduled
     * - "Storniert" if cancelled
     * - Status name otherwise
     *
     * @return string
     */
    public function getStatusBadge(): string
    {
        if ($this->wasRescheduled() && !$this->isCancelled()) {
            return 'Verschoben';
        }

        return match($this->status) {
            'cancelled' => 'Storniert',
            'confirmed' => 'Bestätigt',
            'completed' => 'Abgeschlossen',
            'pending' => 'Ausstehend',
            'no_show' => 'Nicht erschienen',
            'in_progress' => 'In Bearbeitung',
            default => ucfirst($this->status ?? 'Unbekannt'),
        };
    }

    /**
     * Get the latest cancellation modification record
     *
     * @return \App\Models\AppointmentModification|null
     */
    public function getCancellationRecord(): ?AppointmentModification
    {
        if (!$this->isCancelled()) {
            return null;
        }

        return $this->modifications()
            ->where('modification_type', 'cancel')
            ->latest('created_at')
            ->first();
    }

    /**
     * Get the call where this appointment was cancelled
     * Returns the call_id from the cancellation metadata
     *
     * @return \App\Models\Call|null
     */
    public function getCancellationCall(): ?Call
    {
        $cancellation = $this->getCancellationRecord();

        if (!$cancellation) {
            return null;
        }

        // Check metadata for call_id
        $metadata = $cancellation->metadata ?? [];
        $callId = $metadata['call_id'] ?? null;

        if (!$callId) {
            return null;
        }

        // Extract numeric ID from call_xxx format
        if (is_string($callId) && str_starts_with($callId, 'call_')) {
            // This is a Retell call ID - find the Call record
            return Call::where('retell_call_id', $callId)->first();
        }

        // Numeric call ID
        return Call::find($callId);
    }

    /**
     * Get the call where this appointment was originally booked
     *
     * @return \App\Models\Call|null
     */
    public function getBookingCall(): ?Call
    {
        if (!$this->call_id) {
            return null;
        }

        return Call::find($this->call_id);
    }

    /**
     * Get cancellation summary for admin display
     *
     * @return array{
     *   cancelled_at: string|null,
     *   cancelled_by: string|null,
     *   reason: string|null,
     *   fee: float,
     *   within_policy: bool,
     *   hours_notice: float|null,
     *   cancellation_call_id: int|null,
     *   booking_call_id: int|null
     * }
     */
    public function getCancellationSummary(): array
    {
        $cancellation = $this->getCancellationRecord();

        if (!$cancellation) {
            return [
                'cancelled_at' => null,
                'cancelled_by' => null,
                'reason' => null,
                'fee' => 0,
                'within_policy' => true,
                'hours_notice' => null,
                'cancellation_call_id' => null,
                'booking_call_id' => null,
            ];
        }

        $metadata = $cancellation->metadata ?? [];
        $cancellationCall = $this->getCancellationCall();
        $bookingCall = $this->getBookingCall();

        return [
            'cancelled_at' => $cancellation->created_at->format('d.m.Y H:i'),
            'cancelled_by' => $this->formatModifiedBy($cancellation->modified_by_type),
            'reason' => $cancellation->reason ?? 'Kein Grund angegeben',
            'fee' => (float) $cancellation->fee_charged,
            'within_policy' => (bool) $cancellation->within_policy,
            'hours_notice' => $metadata['hours_notice'] ?? null,
            'cancellation_call_id' => $cancellationCall?->id,
            'booking_call_id' => $bookingCall?->id,
        ];
    }

    /**
     * Format modified_by_type for display
     *
     * @param string|null $type
     * @return string
     */
    protected function formatModifiedBy(?string $type): string
    {
        return match($type) {
            'User' => 'Admin',
            'Staff' => 'Mitarbeiter',
            'Customer' => 'Kunde',
            'System' => 'System/AI',
            default => $type ?? 'Unbekannt',
        };
    }
}