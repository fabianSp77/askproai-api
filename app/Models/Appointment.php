<?php

namespace App\Models;

use App\Traits\BelongsToCompany;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Appointment extends Model
{
    use HasFactory, SoftDeletes, BelongsToCompany;

    /**
     * Mass Assignment Protection
     *
     * SECURITY: Protects against VULN-009 - Mass Assignment vulnerability
     * Tenant isolation and financial fields must never be mass-assigned
     */
    protected $guarded = [
        'id',                    // Primary key

        // Multi-tenant isolation (CRITICAL)
        'company_id',            // Must be set only via service/customer relationship
        'branch_id',             // Must be set only via service/customer relationship

        // Financial data (CRITICAL)
        'price',                 // Calculated from service
        'total_price',           // Calculated field

        // Locking mechanism (CRITICAL)
        'lock_token',            // Generated by locking system
        'lock_expires_at',       // Set by locking system
        'version',               // Optimistic locking counter

        // System notification timestamps
        'reminder_24h_sent_at',  // Set by notification system

        // System timestamps
        'created_at',
        'updated_at',
        'deleted_at',
    ];

    protected $casts = [
        'metadata' => 'array',
        'is_recurring' => 'boolean',
        'recurring_pattern' => 'array',
        'price' => 'decimal:2',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        // Composite casts
        'is_composite' => 'boolean',
        'segments' => 'array',
        'starts_at' => 'datetime',
        'ends_at' => 'datetime',
    ];

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class);
    }

    public function staff(): BelongsTo
    {
        return $this->belongsTo(Staff::class);
    }

    public function branch(): BelongsTo
    {
        return $this->belongsTo(Branch::class);
    }

    public function service(): BelongsTo
    {
        return $this->belongsTo(Service::class);
    }

    /**
     * Call that originated this appointment
     */
    public function call(): BelongsTo
    {
        return $this->belongsTo(Call::class, 'call_id');
    }

    /**
     * Cal.com host mapping for this appointment (Phase 2: Staff Assignment)
     */
    public function calcomHostMapping(): BelongsTo
    {
        return $this->belongsTo(CalcomHostMapping::class, 'calcom_host_id', 'calcom_host_id');
    }

    /**
     * Check if appointment is composite
     */
    public function isComposite(): bool
    {
        return $this->is_composite === true;
    }

    /**
     * Get segments for composite appointment
     */
    public function getSegments(): array
    {
        return $this->segments ?? [];
    }

    /**
     * Scope for composite appointments
     */
    public function scopeComposite($query)
    {
        return $query->where('is_composite', true);
    }

    /**
     * Scope for simple appointments
     */
    public function scopeSimple($query)
    {
        return $query->where('is_composite', false);
    }

    /**
     * Related appointments in same composite group
     */
    public function compositeGroup()
    {
        if (!$this->composite_group_uid) {
            return collect();
        }
        return static::where('composite_group_uid', $this->composite_group_uid)
            ->orderBy('starts_at')
            ->get();
    }

    /**
     * Parent appointment for recurring series
     */
    public function parentAppointment(): BelongsTo
    {
        return $this->belongsTo(Appointment::class, 'parent_appointment_id');
    }

    /**
     * Child appointments for recurring series
     */
    public function children(): HasMany
    {
        return $this->hasMany(Appointment::class, 'parent_appointment_id');
    }

    /**
     * Recurring pattern configuration
     */
    public function recurringPattern(): HasOne
    {
        return $this->hasOne(RecurringAppointmentPattern::class);
    }

    /**
     * Check if this is part of a recurring series
     */
    public function isPartOfRecurringSeries(): bool
    {
        return $this->is_recurring || $this->parent_appointment_id !== null;
    }

    /**
     * Get the root parent of recurring series
     */
    public function getRootParent(): ?Appointment
    {
        if ($this->parent_appointment_id) {
            return $this->parentAppointment;
        }
        if ($this->is_recurring) {
            return $this;
        }
        return null;
    }

    /**
     * Scope for recurring appointments
     */
    public function scopeRecurring($query)
    {
        return $query->where('is_recurring', true);
    }

    /**
     * Scope for non-recurring appointments
     */
    public function scopeNonRecurring($query)
    {
        return $query->where('is_recurring', false)
            ->whereNull('parent_appointment_id');
    }
}