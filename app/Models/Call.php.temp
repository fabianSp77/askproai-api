<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Builder;
use Carbon\Carbon;

class Call extends Model
{
    use HasFactory;

    protected $table = 'calls';
    
    protected $guarded = [];

    protected $casts = [
        'raw_data' => 'array',
        'analysis' => 'array',
        'webhook_data' => 'array',
        'successful' => 'boolean',
        'call_time' => 'datetime',
        'cost' => 'decimal:2',
        'tags' => 'array'
    ];
    
    protected $appends = ['has_recording', 'sentiment'];

    public function customer()
    {
        return $this->belongsTo(Customer::class);
    }
    
    public function appointment()
    {
        return $this->belongsTo(Appointment::class);
    }
    
    public function appointmentViaCallId()
    {
        return $this->hasOne(Appointment::class);
    }
    
    public function agent()
    {
        return $this->belongsTo(Agent::class, 'agent_id', 'agent_id');
    }
    
    public function company()
    {
        return $this->belongsTo(Company::class);
    }

    /**
     * Scope for recent calls
     */
    public function scopeRecent(Builder $query, int $days = 7): Builder
    {
        return $query->where('created_at', '>=', now()->subDays($days))
                     ->orderBy('created_at', 'desc');
    }

    /**
     * Scope for today's calls
     */
    {
        return $query->whereDate('created_at', today())
                     ->orderBy('created_at', 'desc');
    }

    /**
     * Scope for calls in a date range
     */
    public function scopeDateRange(Builder $query, $startDate, $endDate): Builder
    {
        $start = Carbon::parse($startDate)->startOfDay();
        $end = Carbon::parse($endDate)->endOfDay();
        
        return $query->whereBetween('created_at', [$start, $end])
                     ->orderBy('created_at', 'desc');
    }

    /**
     * Scope for calls by status
     */
    public function scopeByStatus(Builder $query, $status): Builder
    {
        if (is_array($status)) {
            return $query->whereIn('status', $status);
        }
        
        return $query->where('status', $status);
    }

    /**
     * Scope for successful calls
     */
    public function scopeSuccessful(Builder $query): Builder
    {
        return $query->where('successful', true);
    }

    /**
     * Scope for failed calls
     */
    public function scopeFailed(Builder $query): Builder
    {
        return $query->where('successful', false);
    }

    /**
     * Scope for calls by phone number
     */
    public function scopeFromNumber(Builder $query, string $phoneNumber): Builder
    {
        $normalizedPhone = $this->normalizePhoneNumber($phoneNumber);
        
        return $query->where(function ($q) use ($phoneNumber, $normalizedPhone) {
            $q->where('from_number', $phoneNumber)
              ->orWhere('from_number', $normalizedPhone)
              ->orWhere('from_number', 'LIKE', '%' . substr($normalizedPhone, -10) . '%');
        });
    }

    /**
     * Scope for calls by company
     */
    public function scopeForCompany(Builder $query, $companyId): Builder
    {
        return $query->where('company_id', $companyId);
    }

    /**
     * Scope for calls with customer
     */
    public function scopeWithCustomer(Builder $query): Builder
    {
        return $query->whereNotNull('customer_id');
    }

    /**
     * Scope for calls without customer
     */
    public function scopeWithoutCustomer(Builder $query): Builder
    {
        return $query->whereNull('customer_id');
    }

    /**
     * Scope for calls with appointment
     */
    public function scopeWithAppointment(Builder $query): Builder
    {
        return $query->whereNotNull('appointment_id');
    }

    /**
     * Scope for calls with relations
     */
    public function scopeWithRelations(Builder $query): Builder
    {
        return $query->with([
            'customer:id,name,phone,email',
            'agent:id,name',
            'appointment:id,starts_at,status'
        ]);
    }

    /**
     * Scope for calls with high duration
     */
    public function scopeLongDuration(Builder $query, int $seconds = 300): Builder
    {
        return $query->where('duration_sec', '>', $seconds);
    }

    /**
     * Scope for calls with high cost
     */
    public function scopeHighCost(Builder $query, float $amount = 5.0): Builder
    {
        return $query->where('cost', '>', $amount);
    }

    /**
     * Normalize phone number for consistent searching
     */
    private function normalizePhoneNumber(string $phone): string
    {
        // Remove all non-numeric characters
        $phone = preg_replace('/[^0-9]/', '', $phone);
        
        // If it starts with country code, keep it
        if (strpos($phone, '49') === 0) {
            return '+' . $phone;
        }
        
        // If it starts with 0, replace with +49
        if (strpos($phone, '0') === 0) {
            return '+49' . substr($phone, 1);
        }
        
        return $phone;
    }
    
    /**
     * Get has_recording attribute
     */
    public function getHasRecordingAttribute(): bool
    {
        return !empty($this->webhook_data['recording_url']);
    }
    
    /**
     * Get sentiment attribute
     */
    public function getSentimentAttribute(): ?string
    {
        return $this->analysis['sentiment'] ?? null;
    }
    
    /**
     * Get formatted duration
     */
    public function getFormattedDurationAttribute(): string
    {
        return gmdate('i:s', $this->duration_sec ?? 0);
    }
    
    /**
     * Extract entities from transcript
     */
    public function extractEntities(): array
    {
        $entities = [];
        $transcript = $this->transcript ?? $this->webhook_data['transcript'] ?? '';
        
        // Extract email
        if (preg_match('/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/', $transcript, $matches)) {
            $entities['email'] = $matches[0];
        }
        
        // Extract phone numbers
        if (preg_match('/(?:\+49|0)[0-9\s\-\/]{10,}/', $transcript, $matches)) {
            $entities['phone'] = $matches[0];
        }
        
        // Extract dates (simple German format)
        if (preg_match('/(\d{1,2})\.(\d{1,2})\.(\d{4}|\d{2})/', $transcript, $matches)) {
            $entities['date'] = $matches[0];
        }
        
        // Extract times
        if (preg_match('/(\d{1,2}):(\d{2})\s?(Uhr)?/', $transcript, $matches)) {
            $entities['time'] = $matches[0];
        }
        
        return $entities;
    }
    
    /**
     * Analyze sentiment from transcript
     */
    public function analyzeSentiment(): string
    {
        $transcript = strtolower($this->transcript ?? $this->webhook_data['transcript'] ?? '');
        
        $positiveWords = ['danke', 'super', 'toll', 'perfekt', 'gut', 'gerne', 'freue', 'klasse', 'wunderbar', 'ja'];
        $negativeWords = ['problem', 'schlecht', 'nein', 'nicht', 'leider', 'schwierig', 'Ã¤rger', 'beschwerde', 'unzufrieden'];
        
        $positiveCount = 0;
        $negativeCount = 0;
        
        foreach ($positiveWords as $word) {
            $positiveCount += substr_count($transcript, $word);
        }
        
        foreach ($negativeWords as $word) {
            $negativeCount += substr_count($transcript, $word);
        }
        
        if ($positiveCount > $negativeCount * 1.5) {
            return 'positive';
        } elseif ($negativeCount > $positiveCount * 1.5) {
            return 'negative';
        }
        
        return 'neutral';
    }
    
    /**
     * Get important phrases from transcript
     */
    public function getImportantPhrases(): array
    {
        $transcript = $this->transcript ?? $this->webhook_data['transcript'] ?? '';
        $phrases = [];
        
        // Extract appointment requests
        if (preg_match('/termin.{0,20}(buchen|vereinbaren|machen)/i', $transcript, $matches)) {
            $phrases[] = $matches[0];
        }
        
        // Extract service mentions
        $services = ['beratung', 'behandlung', 'haarschnitt', 'massage', 'untersuchung'];
        foreach ($services as $service) {
            if (stripos($transcript, $service) !== false) {
                $phrases[] = ucfirst($service);
            }
        }
        
        return array_unique($phrases);
    }
    
    /**
     * Boot method to auto-analyze calls
     */
    protected static function boot()
    {
        parent::boot();
        
        static::saving(function ($call) {
            // Auto-analyze if we have a transcript
            if (!empty($call->transcript) || !empty($call->webhook_data['transcript'])) {
                if (empty($call->analysis)) {
                    $call->analysis = [];
                }
                
                // Extract entities
                $call->analysis['entities'] = $call->extractEntities();
                
                // Analyze sentiment
                $call->analysis['sentiment'] = $call->analyzeSentiment();
                
                // Get important phrases
                $call->analysis['important_phrases'] = $call->getImportantPhrases();
                
                // Determine intent
                $transcript = strtolower($call->transcript ?? $call->webhook_data['transcript'] ?? '');
                if (stripos($transcript, 'termin') !== false) {
                    $call->analysis['intent'] = 'appointment_booking';
                } elseif (stripos($transcript, 'storn') !== false || stripos($transcript, 'absag') !== false) {
                    $call->analysis['intent'] = 'cancellation';
                } elseif (stripos($transcript, 'frage') !== false || stripos($transcript, 'information') !== false) {
                    $call->analysis['intent'] = 'inquiry';
                }
            }
        });
    }
}
