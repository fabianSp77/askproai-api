<?php

namespace App\Models;

use App\Traits\BelongsToCompany;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Customer extends Model
{
    use HasFactory, SoftDeletes, BelongsToCompany;

    /**
     * Mass Assignment Protection
     *
     * SECURITY: Protects against VULN-009 - Mass Assignment vulnerability
     * Tenant isolation and financial fields must never be mass-assigned
     */
    protected $guarded = [
        'id',                           // Primary key

        // Multi-tenant isolation (CRITICAL)
        'company_id',                   // Must be set only via authentication context

        // Financial data (CRITICAL - calculated fields)
        'total_spent',                  // Calculated from appointments
        'total_revenue',                // Calculated from appointments
        'average_booking_value',        // Calculated field
        'loyalty_points',               // Must be modified through loyalty system
        'loyalty_tier',                 // Calculated based on loyalty_points

        // Authentication & Security (CRITICAL)
        'portal_access_token',          // Generated by auth system
        'portal_token_expires_at',      // Set by auth system
        'security_flags',               // Set by security system
        'failed_verification_attempts', // Security counter
        'last_security_check',          // Security timestamp

        // Calculated statistics (should not be mass-assigned)
        'appointment_count',            // Calculated from appointments
        'completed_appointments',       // Calculated from appointments
        'cancelled_appointments',       // Calculated from appointments
        'no_show_appointments',         // Calculated from appointments
        'no_show_count',                // Calculated from appointments
        'cancelled_count',              // Calculated from appointments
        'call_count',                   // Calculated from calls

        // System timestamps
        'created_at',
        'updated_at',
        'deleted_at',
        'last_seen_at',
        'last_call_at',
        'last_appointment_at',
        'last_portal_login_at',
        'first_appointment_date',
        'last_appointment_date',
        'journey_status_updated_at',
    ];

    protected $casts = [
        'phone_variants' => 'array',
        'journey_history' => 'array',
        'tags' => 'array',
        'location_data' => 'array',
        'preference_data' => 'array',
        'custom_attributes' => 'array',
        'communication_preferences' => 'array',
        'booking_history_summary' => 'array',
        'security_flags' => 'array',
        'is_vip' => 'boolean',
        'portal_enabled' => 'boolean',
        'journey_status_updated_at' => 'datetime',
        'privacy_consent_at' => 'datetime',
        'marketing_consent_at' => 'datetime',
        'deletion_requested_at' => 'datetime',
        'portal_token_expires_at' => 'datetime',
        'last_portal_login_at' => 'datetime',
        'last_seen_at' => 'datetime',
        'last_call_at' => 'datetime',
        'last_appointment_at' => 'datetime',
        'first_appointment_date' => 'date',
        'last_appointment_date' => 'date',
        'vip_since' => 'date',
        'birthday' => 'date',
        'last_security_check' => 'datetime',
        'email_verified_at' => 'datetime',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    protected $hidden = [
        'password',
        'remember_token',
        'portal_access_token',
    ];

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function calls(): HasMany
    {
        return $this->hasMany(Call::class);
    }

    public function appointments(): HasMany
    {
        return $this->hasMany(Appointment::class);
    }

    public function appointmentModificationStats(): HasMany
    {
        return $this->hasMany(AppointmentModificationStat::class);
    }

    /**
     * Get all appointment modifications (cancellations, reschedulings) for this customer
     * Used for engagement scoring and policy violation tracking
     */
    public function appointmentModifications(): HasMany
    {
        return $this->hasMany(AppointmentModification::class);
    }

    /**
     * Get upcoming scheduled/confirmed appointments for this customer
     * Used for customer portal, booking confirmation, and engagement tracking
     * Performance: More efficient than filtering appointments() every time
     */
    public function upcomingAppointments(): HasMany
    {
        return $this->appointments()
            ->where('starts_at', '>=', now())
            ->whereIn('status', ['scheduled', 'confirmed'])
            ->orderBy('starts_at', 'asc');
    }

    /**
     * Get completed appointments for this customer (historical record)
     * Used for customer history, completion tracking, and analytics
     * Performance: Specialized query for completed appointments only
     */
    public function completedAppointments(): HasMany
    {
        return $this->appointments()
            ->where('status', 'completed')
            ->orderBy('starts_at', 'desc');
    }

    /**
     * Get recent calls within last 90 days for this customer
     * Used for engagement scoring, call history, and quality assurance
     * Performance: Filters to recent period for faster queries
     */
    public function recentCalls(): HasMany
    {
        return $this->calls()
            ->where('created_at', '>=', now()->subDays(90))
            ->orderBy('created_at', 'desc');
    }

    public function invoices(): HasMany
    {
        return $this->hasMany(Invoice::class);
    }

    public function preferredBranch(): BelongsTo
    {
        return $this->belongsTo(Branch::class, 'preferred_branch_id');
    }

    public function preferredStaff(): BelongsTo
    {
        return $this->belongsTo(Staff::class, 'preferred_staff_id');
    }

    public function notes()
    {
        return $this->hasMany(CustomerNote::class)->orderBy('is_pinned', 'desc')->orderBy('created_at', 'desc');
    }


    // Query Scopes for optimization
    public function scopeActive($query)
    {
        return $query->where('status', 'active');
    }

    public function scopeInactive($query)
    {
        return $query->where('status', 'inactive');
    }

    public function scopeVip($query)
    {
        return $query->where('is_vip', true);
    }

    public function scopeWithUpcomingAppointments($query)
    {
        return $query->whereHas('appointments', function ($q) {
            $q->where('starts_at', '>=', now())
              ->whereIn('status', ['scheduled', 'confirmed']);
        });
    }

    public function scopeByJourneyStage($query, $stage)
    {
        return $query->where('journey_status', $stage);
    }

    public function scopeHighValue($query, $minRevenue = 1000)
    {
        return $query->where('total_revenue', '>', $minRevenue);
    }

    public function scopeWithRecentActivity($query, $days = 30)
    {
        return $query->where(function ($q) use ($days) {
            $q->where('last_appointment_at', '>=', now()->subDays($days))
              ->orWhere('last_call_at', '>=', now()->subDays($days));
        });
    }

    public function scopeAtRisk($query)
    {
        return $query->where('status', 'active')
            ->where(function ($q) {
                $q->where('last_appointment_at', '<', now()->subDays(90))
                  ->orWhereNull('last_appointment_at');
            })
            ->where(function ($q) {
                $q->where('last_call_at', '<', now()->subDays(60))
                  ->orWhereNull('last_call_at');
            });
    }

    public function scopeWithRelations($query)
    {
        return $query->with(['company', 'preferredBranch', 'preferredStaff']);
    }

    // Helper methods
    public function updateJourneyStatus($newStatus, $reason = null)
    {
        $history = $this->journey_history ?? [];
        $history[] = [
            'from' => $this->journey_status,
            'to' => $newStatus,
            'reason' => $reason,
            'changed_at' => now()->toIso8601String(),
            'changed_by' => auth()->id(),
        ];

        $this->update([
            'journey_status' => $newStatus,
            'journey_status_updated_at' => now(),
            'journey_history' => $history,
        ]);
    }

    public function calculateLifetimeValue()
    {
        return $this->total_revenue + ($this->average_booking_value * $this->loyalty_points / 100);
    }

    public function getDaysSinceLastContactAttribute()
    {
        $lastContact = collect([
            $this->last_appointment_at,
            $this->last_call_at,
            $this->last_seen_at,
        ])->filter()->max();

        return $lastContact ? now()->diffInDays($lastContact) : null;
    }

    public function getIsAtRiskAttribute()
    {
        return $this->days_since_last_contact > 90;
    }

    public function getNextAppointmentAttribute()
    {
        return $this->appointments()
            ->where('starts_at', '>=', now())
            ->whereIn('status', ['scheduled', 'confirmed'])
            ->orderBy('starts_at')
            ->first();
    }

    public function getEngagementScore()
    {
        $score = 0;

        // Points for appointments
        $score += $this->appointment_count * 10;
        $score += $this->completed_appointments * 5;

        // Points for calls
        $score += $this->call_count * 3;

        // Points for recent activity
        if ($this->last_appointment_at && $this->last_appointment_at >= now()->subDays(30)) {
            $score += 20;
        }
        if ($this->last_call_at && $this->last_call_at >= now()->subDays(14)) {
            $score += 10;
        }

        // Penalty for no-shows and cancellations
        $score -= $this->no_show_count * 5;
        $score -= $this->cancelled_count * 2;

        // VIP bonus
        if ($this->is_vip) {
            $score += 50;
        }

        return max(0, $score);
    }
}