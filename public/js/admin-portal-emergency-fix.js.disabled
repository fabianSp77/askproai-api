/**
 * Admin Portal Emergency Fix - Direct Solution
 * This replaces ALL previous attempts with a minimal, working solution
 */

console.log('[Emergency Fix] Starting admin portal repair...');

// Wait for DOM to be ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initFix);
} else {
    initFix();
}

function initFix() {
    console.log('[Emergency Fix] Initializing fixes...');
    
    // Fix 1: Force all Filament dropdowns to work
    fixFilamentDropdowns();
    
    // Fix 2: Make all links and buttons clickable
    makeEverythingClickable();
    
    // Fix 3: Setup Alpine if needed
    if (typeof Alpine !== 'undefined') {
        setupAlpineFixes();
    }
    
    // Fix 4: Monitor for new elements
    observeChanges();
    
    console.log('[Emergency Fix] All fixes applied!');
}

function fixFilamentDropdowns() {
    console.log('[Emergency Fix] Fixing Filament dropdowns...');
    
    // Find all dropdown triggers and make them work
    document.addEventListener('click', function(e) {
        // Check if clicked element is a dropdown trigger
        const trigger = e.target.closest('[x-on\\:click*="open"], [x-on\\:click*="toggle"], .fi-dropdown-trigger');
        
        if (trigger) {
            e.stopImmediatePropagation(); // Stop other handlers
            
            // Find the Alpine component
            const component = trigger.closest('[x-data]');
            if (component && component._x_dataStack) {
                const data = component._x_dataStack[0];
                
                // Toggle the dropdown
                if (data && typeof data.open !== 'undefined') {
                    data.open = !data.open;
                    console.log('[Emergency Fix] Toggled dropdown:', data.open);
                }
            }
        }
    });
    
    // Close dropdowns when clicking outside
    document.addEventListener('click', function(e) {
        if (!e.target.closest('[x-data*="open"]')) {
            // Close all open dropdowns
            document.querySelectorAll('[x-data*="open"]').forEach(dropdown => {
                if (dropdown._x_dataStack) {
                    const data = dropdown._x_dataStack[0];
                    if (data && data.open === true) {
                        data.open = false;
                    }
                }
            });
        }
    });
}

function makeEverythingClickable() {
    console.log('[Emergency Fix] Making everything clickable...');
    
    // Create a style element to override ALL pointer-events
    const style = document.createElement('style');
    style.id = 'emergency-pointer-fix';
    style.textContent = `
        /* Emergency pointer fix */
        *, *::before, *::after {
            pointer-events: auto !important;
        }
        
        /* Specific elements that should definitely be clickable */
        a, button, input, select, textarea,
        [role="button"], [role="link"],
        [onclick], [wire\\:click], [x-on\\:click],
        .fi-btn, .fi-link, .fi-dropdown-trigger,
        .fi-dropdown-item, .fi-ta-action, .fi-ta-link {
            pointer-events: auto !important;
            cursor: pointer !important;
            position: relative !important;
            z-index: auto !important;
        }
        
        /* Only these should NOT capture clicks */
        .fi-loading-indicator::before,
        .fi-loading-indicator::after {
            pointer-events: none !important;
        }
    `;
    
    // Remove any existing emergency styles
    const existing = document.getElementById('emergency-pointer-fix');
    if (existing) {
        existing.remove();
    }
    
    // Add to head
    document.head.appendChild(style);
}

function setupAlpineFixes() {
    console.log('[Emergency Fix] Setting up Alpine fixes...');
    
    // Override problematic functions
    window.toggleDropdown = function() {
        console.log('[Emergency Fix] toggleDropdown called');
        if (this && this.open !== undefined) {
            this.open = !this.open;
            return false; // Prevent default
        }
    };
    
    window.closeDropdown = function() {
        console.log('[Emergency Fix] closeDropdown called');
        if (this && this.open !== undefined) {
            this.open = false;
            return false; // Prevent default
        }
    };
}

function observeChanges() {
    console.log('[Emergency Fix] Setting up observer...');
    
    // Re-apply fixes when DOM changes
    const observer = new MutationObserver((mutations) => {
        // Check if new interactive elements were added
        const hasNewElements = mutations.some(m => 
            m.addedNodes.length > 0 && 
            Array.from(m.addedNodes).some(node => 
                node.nodeType === 1 && (
                    node.matches?.('a, button, [role="button"]') ||
                    node.querySelector?.('a, button, [role="button"]')
                )
            )
        );
        
        if (hasNewElements) {
            console.log('[Emergency Fix] New elements detected, reapplying fixes...');
            makeEverythingClickable();
        }
    });
    
    observer.observe(document.body, {
        childList: true,
        subtree: true
    });
}

// Debug helper
window.emergencyDebug = function() {
    console.log('=== Emergency Debug Info ===');
    
    // Check dropdowns
    const dropdowns = document.querySelectorAll('[x-data*="open"]');
    console.log('Dropdowns found:', dropdowns.length);
    
    // Check clickable elements
    const clickable = document.querySelectorAll('a, button, [role="button"]');
    let blocked = 0;
    clickable.forEach(el => {
        const style = getComputedStyle(el);
        if (style.pointerEvents === 'none') {
            blocked++;
            console.warn('Blocked element:', el);
        }
    });
    
    console.log('Clickable elements:', clickable.length);
    console.log('Blocked elements:', blocked);
    
    // Check for problematic styles
    const sheets = Array.from(document.styleSheets);
    sheets.forEach((sheet, i) => {
        try {
            const rules = Array.from(sheet.cssRules || []);
            rules.forEach(rule => {
                if (rule.cssText && rule.cssText.includes('pointer-events: none')) {
                    console.warn(`Sheet ${i} has pointer-events: none rule:`, rule.cssText);
                }
            });
        } catch (e) {
            // Cross-origin stylesheets can't be read
        }
    });
    
    return {
        dropdowns: dropdowns.length,
        clickable: clickable.length,
        blocked: blocked
    };
};