# SQL Injection Vulnerability Report - AskProAI

Generated: 2025-06-24

## Executive Summary

After a comprehensive scan of the `/var/www/api-gateway/app` directory, I identified several areas with potential SQL injection vulnerabilities. The most critical findings involve uses of `whereRaw()` and `DB::raw()` with potentially unsanitized input.

## Critical Vulnerabilities Found

### 1. **whereRaw() with User Input (HIGH RISK)**

#### File: `/var/www/api-gateway/app/Services/RealTime/IntelligentCallRouter.php`
- **Lines 158-159**: Direct use of `whereRaw()` with JSON_EXTRACT
```php
->whereRaw("JSON_EXTRACT(working_hours, '$.{$dayOfWeek}.start') <= ?", [$currentTime])
->whereRaw("JSON_EXTRACT(working_hours, '$.{$dayOfWeek}.end') >= ?", [$currentTime]);
```
- **Risk**: While parameters are bound, the `$dayOfWeek` variable is interpolated directly into the query
- **Severity**: HIGH - Could allow SQL injection if `$dayOfWeek` is not properly validated

#### File: `/var/www/api-gateway/app/Services/RealTime/ConcurrentCallManager.php`
- **Lines 180-181**: Similar pattern with whereRaw and JSON_EXTRACT
```php
->whereRaw("JSON_EXTRACT(working_hours, '$.{$dayOfWeek}.start') <= ?", [$currentTime])
->whereRaw("JSON_EXTRACT(working_hours, '$.{$dayOfWeek}.end') >= ?", [$currentTime]);
```
- **Risk**: Same as above - string interpolation in SQL query
- **Severity**: HIGH

### 2. **DB::raw() with Variable Interpolation (MEDIUM RISK)**

#### File: `/var/www/api-gateway/app/Services/QueryOptimizer.php`
- **Line 44**: Uses DB::raw() with sanitized but still interpolated values
```php
$query->from(DB::raw("`{$table}` USE INDEX ({$indexList})"));
```
- **Lines 323**: Force index implementation
```php
$query->from(DB::raw("{$table} FORCE INDEX ({$index})"));
```
- **Risk**: While there's sanitization (preg_replace), direct interpolation is still risky
- **Severity**: MEDIUM - Sanitization present but not foolproof

### 3. **selectRaw() with Dynamic Content (MEDIUM RISK)**

#### File: `/var/www/api-gateway/app/Filament/Admin/Resources/CallResource/Widgets/CallQualityWidget.php`
- **Lines 36-40**: Uses selectRaw() with JSON_EXTRACT
```php
->selectRaw("
    SUM(CASE WHEN JSON_EXTRACT(analysis, '$.sentiment') = 'positive' THEN 1 ELSE 0 END) as positive,
    SUM(CASE WHEN JSON_EXTRACT(analysis, '$.sentiment') = 'negative' THEN 1 ELSE 0 END) as negative,
    SUM(CASE WHEN JSON_EXTRACT(analysis, '$.sentiment') = 'neutral' THEN 1 ELSE 0 END) as neutral
")
```
- **Risk**: While this specific case is safe (no user input), the pattern could be dangerous if copied
- **Severity**: LOW (in this case)

### 4. **Direct SQL in Migration Files (LOW RISK)**

#### File: `/var/www/api-gateway/app/Database/CompatibleMigration.php`
- **Line 114**: Uses DB::update with string interpolation
```php
DB::update("UPDATE {$tableName} SET {$columnName} = ? WHERE {$columnName} IS NULL OR {$columnName} = ''", [$jsonString]);
```
- **Risk**: Table and column names are interpolated directly
- **Severity**: LOW - Migration files typically don't process user input

### 5. **SQL Statement Building (MEDIUM RISK)**

#### File: `/var/www/api-gateway/app/Console/Commands/PerformanceMonitor.php`
- **Lines 100-102**: Executes dynamic SQL queries
```php
DB::select($queryInfo['query'], $params);
```
- **Risk**: While parameters are bound, the query itself could be manipulated
- **Severity**: MEDIUM - Console commands have limited exposure

## Safe Patterns Observed

### Good Practice Example: `/var/www/api-gateway/app/Helpers/SafeQueryHelper.php`
This file demonstrates proper SQL injection prevention:
- Proper escaping for LIKE queries
- Column name sanitization
- Parameter binding
- Whitelist validation for operators

## Recommendations

### 1. **Immediate Actions (Critical)**
- Replace all `whereRaw()` calls that interpolate variables with safer alternatives
- Use parameter binding for all dynamic values
- Validate `$dayOfWeek` variables against a whitelist before use

### 2. **Short-term Improvements**
- Replace DB::raw() with query builder methods where possible
- Implement strict input validation for all user-provided data
- Use prepared statements consistently

### 3. **Long-term Security Enhancements**
- Implement a query audit system
- Use an ORM consistently instead of raw queries
- Regular security audits with automated tools
- Developer training on secure coding practices

## Code Fixes Required

### Fix for IntelligentCallRouter.php and ConcurrentCallManager.php:
```php
// Instead of:
->whereRaw("JSON_EXTRACT(working_hours, '$.{$dayOfWeek}.start') <= ?", [$currentTime])

// Use:
$allowedDays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
if (!in_array($dayOfWeek, $allowedDays)) {
    throw new \InvalidArgumentException('Invalid day of week');
}
->whereRaw("JSON_EXTRACT(working_hours, '$." . $dayOfWeek . ".start') <= ?", [$currentTime])
```

### Fix for QueryOptimizer.php:
```php
// Instead of direct interpolation, use query builder:
$query->from($table)->useIndex($indexes);
// Or if DB::raw is necessary, use parameter binding where possible
```

## Summary

While the codebase shows awareness of SQL injection risks (evident from SafeQueryHelper.php), there are still several vulnerable patterns that need immediate attention. The most critical issues involve `whereRaw()` calls with interpolated variables in the real-time call routing components.

**Total Vulnerabilities Found:**
- HIGH Risk: 2
- MEDIUM Risk: 3
- LOW Risk: 2

**Affected Components:**
- Real-time call routing
- Query optimization
- Dashboard widgets
- Database migrations
- Performance monitoring

Immediate action should be taken on the HIGH risk vulnerabilities in the IntelligentCallRouter and ConcurrentCallManager services.