<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Debug Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; max-width: 1200px; margin: 0 auto; }
        .section { margin: 20px 0; padding: 20px; border: 1px solid #ddd; background: #f9f9f9; }
        .log { font-family: monospace; font-size: 12px; background: #fff; padding: 10px; 
               max-height: 300px; overflow-y: auto; border: 1px solid #ccc; margin-top: 10px; }
        .error { color: red; }
        .warning { color: orange; }
        .success { color: green; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        .metric { display: inline-block; margin: 10px; padding: 10px; background: #fff; border: 1px solid #ddd; }
    </style>
</head>
<body>
    <h1>Admin Performance Debug</h1>
    
    <div class="section">
        <h2>Performance Metrics</h2>
        <div id="metrics">
            <div class="metric">
                <strong>Page Load Time:</strong> <span id="loadTime">...</span>
            </div>
            <div class="metric">
                <strong>DOM Nodes:</strong> <span id="domNodes">...</span>
            </div>
            <div class="metric">
                <strong>Event Listeners:</strong> <span id="eventListeners">...</span>
            </div>
            <div class="metric">
                <strong>Memory Used:</strong> <span id="memoryUsed">...</span>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h2>Active Timers & Observers</h2>
        <button onclick="detectTimers()">Detect Active Timers</button>
        <button onclick="killAllTimers()">Kill All Timers</button>
        <div class="log" id="timerLog"></div>
    </div>
    
    <div class="section">
        <h2>Test Admin Pages</h2>
        <button onclick="testPage('/admin/calls')">Test Calls Page</button>
        <button onclick="testPage('/admin/appointments')">Test Appointments Page</button>
        <button onclick="testPage('/admin/branches')">Test Branches Page</button>
        <div class="log" id="pageLog"></div>
    </div>
    
    <div class="section">
        <h2>Network Monitor</h2>
        <button onclick="startNetworkMonitor()">Start Monitoring</button>
        <button onclick="stopNetworkMonitor()">Stop Monitoring</button>
        <div class="log" id="networkLog"></div>
    </div>
    
    <script>
        // Track all intervals and observers
        const activeIntervals = new Set();
        const activeTimeouts = new Set();
        const originalSetInterval = window.setInterval;
        const originalSetTimeout = window.setTimeout;
        const originalClearInterval = window.clearInterval;
        const originalClearTimeout = window.clearTimeout;
        
        window.setInterval = function(func, delay) {
            const id = originalSetInterval.apply(window, arguments);
            activeIntervals.add({id, func: func.toString(), delay, stack: new Error().stack});
            return id;
        };
        
        window.setTimeout = function(func, delay) {
            const id = originalSetTimeout.apply(window, arguments);
            activeTimeouts.add({id, func: func.toString(), delay, stack: new Error().stack});
            return id;
        };
        
        window.clearInterval = function(id) {
            activeIntervals.forEach(item => {
                if (item.id === id) activeIntervals.delete(item);
            });
            return originalClearInterval.apply(window, arguments);
        };
        
        window.clearTimeout = function(id) {
            activeTimeouts.forEach(item => {
                if (item.id === id) activeTimeouts.delete(item);
            });
            return originalClearTimeout.apply(window, arguments);
        };
        
        // Utility functions
        const log = (message, type = 'info', target = 'timerLog') => {
            const logDiv = document.getElementById(target);
            const time = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'warning' ? 'warning' : type === 'success' ? 'success' : '';
            logDiv.innerHTML += `<div class="${className}">[${time}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        };
        
        const detectTimers = () => {
            log(`Active Intervals: ${activeIntervals.size}`, 'info');
            activeIntervals.forEach(item => {
                log(`Interval ID ${item.id}: ${item.delay}ms`, 'warning');
                log(`Function: ${item.func.substring(0, 100)}...`, 'info');
            });
            
            log(`Active Timeouts: ${activeTimeouts.size}`, 'info');
            
            // Detect MutationObservers (harder to track)
            log('Checking for MutationObservers...', 'info');
            // This is a heuristic - we can't directly access all observers
            const scripts = document.querySelectorAll('script');
            scripts.forEach(script => {
                if (script.textContent && script.textContent.includes('MutationObserver')) {
                    log('Found script with MutationObserver', 'warning');
                }
            });
        };
        
        const killAllTimers = () => {
            let killed = 0;
            activeIntervals.forEach(item => {
                clearInterval(item.id);
                killed++;
            });
            log(`Killed ${killed} intervals`, 'success');
            
            killed = 0;
            activeTimeouts.forEach(item => {
                clearTimeout(item.id);
                killed++;
            });
            log(`Killed ${killed} timeouts`, 'success');
        };
        
        const testPage = async (url) => {
            log(`Testing ${url}...`, 'info', 'pageLog');
            const startTime = performance.now();
            
            try {
                const response = await fetch(url, {
                    method: 'GET',
                    credentials: 'include',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });
                
                const endTime = performance.now();
                const duration = endTime - startTime;
                
                log(`${url}: ${response.status} in ${duration.toFixed(2)}ms`, 
                    response.status === 200 ? 'success' : 'error', 'pageLog');
                
                if (response.status === 200) {
                    const text = await response.text();
                    log(`Page size: ${(text.length / 1024).toFixed(2)} KB`, 'info', 'pageLog');
                    
                    // Check for problematic patterns
                    if (text.includes('setInterval')) {
                        log(`WARNING: Page contains setInterval calls`, 'warning', 'pageLog');
                    }
                    if (text.includes('MutationObserver')) {
                        log(`WARNING: Page contains MutationObserver`, 'warning', 'pageLog');
                    }
                    if (text.includes('419') || text.includes('Page Expired')) {
                        log(`WARNING: Page contains CSRF error references`, 'warning', 'pageLog');
                    }
                }
            } catch (error) {
                log(`${url}: ERROR - ${error.message}`, 'error', 'pageLog');
            }
        };
        
        // Network monitoring
        let networkMonitor = null;
        const networkRequests = [];
        
        const startNetworkMonitor = () => {
            if (networkMonitor) return;
            
            const observer = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    if (entry.entryType === 'resource') {
                        networkRequests.push(entry);
                        const duration = entry.duration.toFixed(2);
                        const status = duration > 1000 ? 'warning' : 'info';
                        log(`${entry.name.split('/').pop()}: ${duration}ms`, status, 'networkLog');
                    }
                }
            });
            
            observer.observe({ entryTypes: ['resource'] });
            networkMonitor = observer;
            log('Network monitoring started', 'success', 'networkLog');
        };
        
        const stopNetworkMonitor = () => {
            if (networkMonitor) {
                networkMonitor.disconnect();
                networkMonitor = null;
                log('Network monitoring stopped', 'info', 'networkLog');
            }
        };
        
        // Update metrics
        const updateMetrics = () => {
            document.getElementById('loadTime').textContent = 
                `${performance.timing.loadEventEnd - performance.timing.navigationStart}ms`;
            
            document.getElementById('domNodes').textContent = 
                document.getElementsByTagName('*').length;
            
            // Estimate event listeners (not exact)
            let listenerCount = 0;
            document.querySelectorAll('*').forEach(el => {
                if (el.onclick || el.onchange || el.onsubmit) listenerCount++;
            });
            document.getElementById('eventListeners').textContent = `~${listenerCount}`;
            
            if (performance.memory) {
                document.getElementById('memoryUsed').textContent = 
                    `${(performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`;
            }
        };
        
        // Initialize
        window.addEventListener('load', () => {
            updateMetrics();
            detectTimers();
        });
    </script>
</body>
</html>