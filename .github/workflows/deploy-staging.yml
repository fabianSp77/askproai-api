# ==============================================================================
# Deploy to Staging (fixed)
# ==============================================================================

name: Deploy to Staging

on:
  workflow_run:
    workflows: ["Build Artifacts"]
    types: [completed]
    branches: [develop]
  workflow_dispatch:
    inputs:
      build_run_id:
        description: 'Optional Build Run ID (defaults to latest successful build)'
        required: false
        type: string

env:
  STAGING_HOST: 152.53.116.127
  STAGING_USER: deploy
  STAGING_BASE_DIR: /var/www/api-gateway-staging
  DOMAIN: staging.askproai.de

jobs:
  # ==========================================================================
  # SSH Secret Validation (Fail-Fast)
  # ==========================================================================
  validate-ssh-secret:
    name: Validate SSH Secret
    runs-on: ubuntu-latest
    timeout-minutes: 5
    environment: staging

    steps:
      - name: Validate STAGING_SSH_KEY Format
        run: |
          echo "üîç Validating STAGING_SSH_KEY format..."

          # Check if secret exists
          if [ -z "${{ secrets.STAGING_SSH_KEY }}" ]; then
            echo "‚ùå STAGING_SSH_KEY secret is empty or not set"
            echo "Please configure STAGING_SSH_KEY in GitHub repository secrets"
            exit 1
          fi

          # Write secret to temp file
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          printf '%s\n' "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/staging_key
          chmod 600 ~/.ssh/staging_key

          # Check for BEGIN marker
          if ! head -n1 ~/.ssh/staging_key | grep -q "BEGIN"; then
            echo "‚ùå Secret does not start with BEGIN marker"
            echo "Expected: -----BEGIN OPENSSH PRIVATE KEY-----"
            echo "Got: $(head -n1 ~/.ssh/staging_key | head -c 50)..."
            exit 1
          fi

          # Count lines
          LINE_COUNT=$(wc -l < ~/.ssh/staging_key)
          echo "üìä Key has $LINE_COUNT lines"

          if [ "$LINE_COUNT" -lt 5 ]; then
            echo "‚ùå Key seems too short (< 5 lines)"
            echo "Please ensure STAGING_SSH_KEY is a complete OpenSSH private key"
            echo "Note: Ed25519 keys are typically 5-7 lines, RSA keys 10+ lines"
            exit 1
          fi

          # Extract fingerprint
          if ! FINGERPRINT=$(ssh-keygen -lf ~/.ssh/staging_key 2>&1); then
            echo "‚ùå Invalid SSH key format"
            echo "Error: $FINGERPRINT"
            exit 1
          fi

          echo "‚úÖ SSH secret validation passed"
          echo "üìã Fingerprint: $FINGERPRINT"

  # ==========================================================================
  # SSH Reachability Check
  # ==========================================================================
  dry-run-ssh:
    name: SSH Reachability Test
    runs-on: ubuntu-latest
    needs: [validate-ssh-secret]
    timeout-minutes: 5
    environment: staging

    steps:
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          printf '%s\n' "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/staging_key
          chmod 600 ~/.ssh/staging_key

      - name: Test SSH Connection
        run: |
          echo "üîå Testing SSH connection to ${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}..."

          # Add host to known_hosts
          ssh-keyscan -H ${{ env.STAGING_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

          # Try SSH connection
          if ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
              ${{ env.STAGING_USER }}@${{ env.STAGING_HOST }} "echo 'SSH connection successful!'" 2>&1; then
            echo "‚úÖ SSH connection works!"
            echo "üéØ Ready for deployment"
          else
            echo "‚ùå SSH connection failed"
            echo ""
            echo "Possible causes:"
            echo "  1. User 'deploy' does not exist on server"
            echo "  2. Public key not in /home/deploy/.ssh/authorized_keys"
            echo "  3. Incorrect permissions on .ssh directory or authorized_keys"
            echo "  4. SSH daemon configuration blocking pubkey authentication"
            echo ""
            echo "To fix, run these commands on the staging server as root:"
            echo "  id -u deploy >/dev/null 2>&1 || adduser --disabled-password --gecos '' deploy"
            echo "  install -d -m 700 -o deploy -g deploy /home/deploy/.ssh"
            echo "  echo 'YOUR_PUBLIC_KEY' >> /home/deploy/.ssh/authorized_keys"
            echo "  chown deploy:deploy /home/deploy/.ssh/authorized_keys"
            echo "  chmod 600 /home/deploy/.ssh/authorized_keys"
            exit 1
          fi

  # ==========================================================================
  # Deploy to Staging
  # ==========================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [dry-run-ssh]
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    timeout-minutes: 30
    environment:
      name: staging
      url: https://staging.askproai.de

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure tools
        run: |
          type jq >/dev/null 2>&1 || { sudo apt-get update && sudo apt-get install -y jq; }
          type gh >/dev/null 2>&1 || { echo "gh CLI fehlt (Runner)"; exit 1; }

      - name: Assert HEALTHCHECK_TOKEN configured
        run: |
          [ -n "${{ secrets.HEALTHCHECK_TOKEN }}" ] || { echo "‚ùå HEALTHCHECK_TOKEN missing"; exit 1; }
          echo "‚úÖ HEALTHCHECK_TOKEN is configured"

      - name: Determine Build Run ID
        id: build_run
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ -n "${{ github.event.workflow_run.id || '' }}" ]; then
            BUILD_RUN_ID="${{ github.event.workflow_run.id }}"
            BUILD_SHA="${{ github.event.workflow_run.head_sha }}"
          elif [ -n "${{ inputs.build_run_id || '' }}" ]; then
            BUILD_RUN_ID="${{ inputs.build_run_id }}"
            BUILD_SHA=$(gh run view "$BUILD_RUN_ID" --json headSha --jq '.headSha')
          else
            SHA="${{ github.sha }}"
            BUILD_RUN_ID=$(gh run list \
              --workflow "Build Artifacts" \
              --branch "${{ github.ref_name }}" \
              --json databaseId,headSha,status,conclusion \
              --limit 20 | jq -r --arg sha "$SHA" \
              '[.[] | select(.headSha==$sha and .status=="completed" and .conclusion=="success")][0].databaseId // empty')
            if [ -z "$BUILD_RUN_ID" ] || [ "$BUILD_RUN_ID" = "null" ]; then
              echo "‚ùå No successful Build Artifacts run found for SHA ${SHA:0:8}"
              exit 1
            fi
            BUILD_SHA="$SHA"
          fi
          echo "BUILD_RUN_ID=$BUILD_RUN_ID" >> $GITHUB_ENV
          echo "BUILD_SHA=$BUILD_SHA"       >> $GITHUB_ENV
          echo "run_id=$BUILD_RUN_ID"       >> $GITHUB_OUTPUT
          echo "sha=$BUILD_SHA"             >> $GITHUB_OUTPUT

      - name: Wait for build artifact
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SHA: ${{ env.BUILD_SHA }}
        run: |
          set -euo pipefail
          echo "‚è≥ Waiting for build artifact for SHA ${SHA:0:8}..."

          for i in $(seq 1 18); do
            RUN_STATUS=$(gh run list \
              --workflow "Build Artifacts" \
              --branch develop \
              --limit 1 \
              --json conclusion,headSha \
              --jq '.[0] | "\(.conclusion) \(.headSha)"')

            read -r CONCLUSION HEAD_SHA <<< "$RUN_STATUS"

            if [ "$CONCLUSION" = "success" ] && [ "${HEAD_SHA:0:8}" = "${SHA:0:8}" ]; then
              echo "‚úÖ Build ready for SHA ${SHA:0:8}"
              exit 0
            fi

            echo "‚è≥ Waiting for build... ($i/18) - Current: $CONCLUSION ${HEAD_SHA:0:8}"
            sleep 10
          done

          echo "‚ùå Build artifact not ready after 3 minutes"
          exit 1

      - name: Download Deployment Bundle
        uses: actions/download-artifact@v4
        with:
          name: deployment-bundle-${{ env.BUILD_SHA }}
          path: ./bundle/
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ env.BUILD_RUN_ID }}

      - name: Inspect Bundle
        run: |
          echo "üì¶ Bundle contents:"
          ls -lh bundle/

          echo ""
          echo "‚úÖ Verifying checksum..."
          cd bundle
          sha256sum -c *.sha256
          cd ..

          echo "‚úÖ Bundle verified successfully"

      - name: Write SSH key from secret
        run: |
          [ -n "${{ secrets.STAGING_SSH_KEY }}" ] || { echo "STAGING_SSH_KEY missing"; exit 1; }
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          printf '%s\n' "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/staging_key
          chmod 600 ~/.ssh/staging_key
          head -n1 ~/.ssh/staging_key | grep -q "BEGIN OPENSSH PRIVATE KEY" || { echo "Invalid key format"; exit 1; }

      - name: Setup known_hosts
        run: |
          ssh-keyscan -H ${{ env.STAGING_HOST }} >> ~/.ssh/known_hosts 2>&1
          ssh-keyscan -H ${{ env.DOMAIN }}       >> ~/.ssh/known_hosts 2>&1 || true

      - name: Upload bundle to server
        run: |
          set -euo pipefail
          BUNDLE_FILE=$(ls bundle/deployment-bundle-*.tar.gz)
          BUNDLE_NAME=$(basename "$BUNDLE_FILE")
          scp -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "$BUNDLE_FILE" "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}:/tmp/"
          echo "BUNDLE_NAME=$BUNDLE_NAME" >> $GITHUB_ENV
          echo "‚úÖ Uploaded $BUNDLE_NAME"

      - name: Prepare release on server
        run: |
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" << EOF
          set -euo pipefail
          TIMESTAMP=\$(date +%Y%m%d_%H%M%S)
          COMMIT_SHA="${{ env.BUILD_SHA }}"
          COMMIT_SHA_SHORT=\${COMMIT_SHA:0:8}
          RELEASE_NAME="\${TIMESTAMP}-\${COMMIT_SHA_SHORT}"
          RELEASE_PATH="${{ env.STAGING_BASE_DIR }}/releases/\${RELEASE_NAME}"
          mkdir -p "\$RELEASE_PATH"
          tar -xzf "/tmp/${BUNDLE_NAME}" -C "\$RELEASE_PATH"
          cd "\$RELEASE_PATH"
          rm -rf storage && ln -s "${{ env.STAGING_BASE_DIR }}/shared/storage" storage
          rm -rf public/uploads && ln -s "${{ env.STAGING_BASE_DIR }}/shared/public/uploads" public/uploads
          ln -s "${{ env.STAGING_BASE_DIR }}/shared/.env/staging.env" .env
          chmod -R 775 bootstrap/cache
          echo "RELEASE_PATH=\$RELEASE_PATH" > /tmp/deploy_env
          EOF

      - name: Verify Release Structure (Pre-Switch Gate)
        run: |
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" << 'EOF'
          set -euo pipefail
          source /tmp/deploy_env
          cd "$RELEASE_PATH"

          echo "üîé Verifying release structure before migrations..."
          echo ""

          # Critical Laravel files
          test -f artisan || { echo "‚ùå PRE-SWITCH GATE FAILED: artisan missing"; exit 1; }
          test -f composer.json || { echo "‚ùå PRE-SWITCH GATE FAILED: composer.json missing"; exit 1; }

          # Public entry point (CRITICAL!)
          test -f public/index.php || { echo "‚ùå PRE-SWITCH GATE FAILED: public/index.php MISSING!"; exit 1; }
          test -f public/build/manifest.json || { echo "‚ùå PRE-SWITCH GATE FAILED: build/manifest.json missing"; exit 1; }

          # Vendor autoload (CRITICAL!)
          test -f vendor/autoload.php || { echo "‚ùå PRE-SWITCH GATE FAILED: vendor/autoload.php MISSING!"; exit 1; }

          # Directory structure
          test -d bootstrap || { echo "‚ùå PRE-SWITCH GATE FAILED: bootstrap/ missing"; exit 1; }
          test -d config || { echo "‚ùå PRE-SWITCH GATE FAILED: config/ missing"; exit 1; }
          test -d routes || { echo "‚ùå PRE-SWITCH GATE FAILED: routes/ missing"; exit 1; }
          test -d app || { echo "‚ùå PRE-SWITCH GATE FAILED: app/ missing"; exit 1; }

          # PHP Autoload test (CRITICAL!)
          php -r "require 'vendor/autoload.php'; echo 'autoload-ok';" | grep -q autoload-ok || {
            echo "‚ùå PRE-SWITCH GATE FAILED: Autoload broken"
            exit 1
          }

          # Artisan test (CRITICAL!)
          echo "Testing artisan..."
          if php artisan --version 2>&1 | head -5; then
            echo "‚úÖ Artisan working"
          else
            echo "‚ùå PRE-SWITCH GATE FAILED: artisan failed"
            echo "Debug info:"
            ls -la artisan .env 2>&1 || true
            php -v 2>&1 | head -2 || true
            exit 1
          fi

          echo "‚úÖ All pre-switch gates PASSED"
          echo ""
          echo "Release structure verified:"
          ls -lah public/ | grep index.php
          ls -lah vendor/ | grep autoload.php
          echo ""
          echo "‚úÖ Release is safe for deployment"
          EOF

      - name: Run migrations
        run: |
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" << 'EOF'
          set -euo pipefail
          source /tmp/deploy_env
          cd "$RELEASE_PATH"
          mkdir -p "${STAGING_BASE_DIR:-/var/www/api-gateway-staging}/shared/storage/backups"
          php artisan migrate --force
          EOF

      - name: Clear caches
        run: |
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" << 'EOF'
          set -euo pipefail
          source /tmp/deploy_env
          cd "$RELEASE_PATH"
          php artisan config:clear || true
          php artisan cache:clear  || true
          php artisan route:clear  || true
          php artisan view:clear   || true
          php artisan optimize:clear || true
          php artisan config:cache || true
          php artisan route:cache  || true
          EOF

      # Storage permissions are configured during initial server setup
      # No sudo required during deployment (least privilege principle)

      - name: Switch current symlink
        run: |
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" << 'EOF'
          set -euo pipefail
          source /tmp/deploy_env
          CURRENT_LINK="${STAGING_BASE_DIR:-/var/www/api-gateway-staging}/current"
          TEMP_LINK="${CURRENT_LINK}_tmp_$$"
          ln -s "$RELEASE_PATH" "$TEMP_LINK"
          mv -Tf "$TEMP_LINK" "$CURRENT_LINK"
          echo "‚úÖ Symlink switched to new release"
          EOF

      - name: Clear caches post-switch
        run: |
          echo "üßπ Clearing all Laravel caches after symlink switch..."
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" /bin/bash -lc '
            set -euo pipefail
            BASE="/var/www/api-gateway-staging"
            CUR="$(readlink -f "$BASE/current")"
            cd "$CUR"

            echo "Clearing Laravel caches..."
            php artisan cache:clear   || true
            php artisan config:clear  || true
            php artisan route:clear   || true
            php artisan view:clear    || true

            echo "‚úÖ All Laravel caches cleared"
          '

      - name: Reload services
        run: |
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" << 'EOF'
          set -euo pipefail

          echo "üîÑ Reloading services (passwordless sudo)..."

          # Detect PHP-FPM version
          PHP_FPM_SERVICE=$(systemctl list-units --type=service | grep -o 'php[0-9.]*-fpm' | head -1)

          if [ -n "$PHP_FPM_SERVICE" ]; then
            echo "Reloading $PHP_FPM_SERVICE..."
            sudo -n service $PHP_FPM_SERVICE reload
            echo "‚úÖ PHP-FPM reloaded"
          else
            echo "‚ö†Ô∏è No PHP-FPM service detected"
          fi

          # Reload NGINX (try systemctl first, fallback to service)
          echo "Reloading NGINX..."
          if sudo -n systemctl reload nginx 2>/dev/null; then
            echo "‚úÖ NGINX reloaded (systemctl)"
          elif sudo -n service nginx reload 2>/dev/null; then
            echo "‚úÖ NGINX reloaded (service)"
          else
            echo "‚ùå NGINX reload failed"
            exit 1
          fi
          EOF

      - name: Reload PHP-FPM to clear OPcache
        run: |
          echo "üîÑ Reloading PHP-FPM to force OPcache clear..."
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" /bin/bash -lc '
            set -euo pipefail
            PHPF=$(systemctl list-units --type=service | grep -o "php[0-9.]*-fpm" | head -1)
            if [ -n "$PHPF" ]; then
              sudo -n service "$PHPF" reload || { echo "‚ö†Ô∏è PHP-FPM reload failed (non-critical)"; }
              echo "‚úÖ PHP-FPM reloaded - OPcache cleared"
            else
              echo "‚ö†Ô∏è No PHP-FPM service detected"
            fi
          '

      - name: Grace period before health checks
        run: |
          echo "‚è≥ Waiting 15 seconds for cache clearing to propagate..."
          sleep 15
          echo "‚úÖ Grace period complete"

      - name: Post-Deploy Health (domain with Bearer)
        env:
          DOMAIN: ${{ env.DOMAIN }}
          HEALTHCHECK_TOKEN: ${{ secrets.HEALTHCHECK_TOKEN }}
        run: |
          set -euo pipefail
          echo "üè• Running comprehensive post-deploy health checks with retry logic..."
          echo ""

          # Test /health and /api/health-check with retry
          for ep in /health /api/health-check; do
            SUCCESS=false
            for i in $(seq 1 6); do
              code=$(curl -sS -o /tmp/out.json -w "%{http_code}" \
                -H "Authorization: Bearer $HEALTHCHECK_TOKEN" \
                "https://$DOMAIN$ep" 2>/dev/null || echo "000")

              echo "  Attempt $i/6: $ep -> HTTP $code"

              if [ -f /tmp/out.json ]; then
                jq -c . </tmp/out.json 2>/dev/null || cat /tmp/out.json || true
              fi

              if [ "$code" = "200" ]; then
                echo "  ‚úÖ $ep: HTTP 200"
                SUCCESS=true
                break
              fi

              if [ "$i" -lt 6 ]; then
                echo "  ‚è≥ Retrying in 5 seconds..."
                sleep 5
              fi
            done

            if [ "$SUCCESS" = "false" ]; then
              echo "  ‚ùå $ep: Failed after 6 attempts (last code: $code)"
              exit 1
            fi
            echo ""
          done

          echo "‚úÖ All Laravel health endpoints passed"

      - name: Public healthcheck.php
        run: |
          echo "üè• Testing public healthcheck.php..."
          code=$(curl -sS -o /tmp/out2.json -w "%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.HEALTHCHECK_TOKEN }}" \
            "https://${{ env.DOMAIN }}/healthcheck.php" 2>/dev/null || echo "000")

          echo "/healthcheck.php -> HTTP $code"
          if [ -f /tmp/out2.json ]; then
            cat /tmp/out2.json || true
          fi

          if [ "$code" != "200" ]; then
            echo "‚ùå /healthcheck.php failed with HTTP $code"
            exit 1
          fi

          echo "‚úÖ Public healthcheck.php passed"

      - name: Vite Asset Validation
        run: |
          echo "üì¶ Validating Vite build artifacts..."

          # Check manifest.json exists and is valid JSON
          MANIFEST_URL="https://${{ env.DOMAIN }}/build/manifest.json"

          if curl -sSf "$MANIFEST_URL" | jq empty; then
            echo "‚úÖ Vite manifest.json is valid"
          else
            echo "‚ùå Vite manifest.json is invalid or missing"
            exit 1
          fi

          # Check at least one asset exists
          ASSET_PATH=$(curl -sSf "$MANIFEST_URL" | jq -r 'to_entries | .[0].value.file')
          ASSET_URL="https://${{ env.DOMAIN }}/build/${ASSET_PATH}"

          if curl -sSf -I "$ASSET_URL" > /dev/null; then
            echo "‚úÖ Vite assets are accessible"
          else
            echo "‚ùå Vite assets not found"
            exit 1
          fi

      - name: Create Deployment Ledger
        run: |
          echo "üìù Creating deployment ledger with SHA256 verification..."

          # Get bundle SHA256
          BUNDLE_SHA256=$(cat bundle/*.sha256 | awk '{print $1}')

          # Create ledger entry
          cat > deployment-ledger.json << LEDGER
          {
            "deployment_id": "${{ github.run_id }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "environment": "staging",
            "commit_sha": "${{ env.BUILD_SHA }}",
            "commit_sha_short": "${BUILD_SHA:0:8}",
            "bundle_name": "${BUNDLE_NAME}",
            "bundle_sha256": "${BUNDLE_SHA256}",
            "deployed_by": "${{ github.actor }}",
            "trigger": "${{ github.event_name }}",
            "health_checks": {
              "healthcheck_php": "passed",
              "health_endpoint": "passed",
              "api_health_check": "passed",
              "vite_assets": "passed"
            },
            "workflow_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          LEDGER

          echo "‚úÖ Deployment ledger created"
          cat deployment-ledger.json | jq '.'

      - name: Upload Deployment Ledger
        uses: actions/upload-artifact@v4
        with:
          name: deployment-ledger-${{ github.run_id }}
          path: deployment-ledger.json
          retention-days: 90

      - name: Cleanup temp
        if: always()
        run: |
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" << EOF
          rm -f "/tmp/${BUNDLE_NAME}" || true
          rm -f /tmp/deploy_env || true
          EOF

  # ==========================================================================
  # Auto-Rollback on Deployment Failure
  # ==========================================================================
  auto-rollback:
    name: Auto-Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: failure() && (github.event_name == 'workflow_run' || github.event_name == 'workflow_dispatch')
    timeout-minutes: 10
    environment: staging

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Write SSH key from secret
        run: |
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          printf '%s\n' "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/staging_key
          chmod 600 ~/.ssh/staging_key

      - name: Setup known_hosts
        run: |
          ssh-keyscan -H ${{ env.STAGING_HOST }} >> ~/.ssh/known_hosts 2>&1

      - name: Execute Rollback
        run: |
          echo "üîÑ Deployment failed! Executing auto-rollback..."

          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no \
            "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" /bin/bash -lc '
            set -euo pipefail
            BASE="/var/www/api-gateway-staging"
            CUR="$BASE/current"
            REL="$BASE/releases"

            # Verify current symlink exists
            test -L "$CUR" || { echo "‚ùå No current deployment found"; exit 1; }

            # Get current and previous releases
            NOW="$(readlink -f "$CUR")"
            PREV="$(ls -1dt "$REL"/* | grep -v "$(basename "$NOW")" | head -1)"

            # Verify previous release exists
            test -d "$PREV" || { echo "‚ùå No previous release found"; exit 1; }

            echo "üìã Rollback Plan:"
            echo "  From: $(basename "$NOW")"
            echo "  To:   $(basename "$PREV")"

            # Perform rollback
            ln -snf "$PREV" "$CUR"
            echo "‚úÖ Updated symlink: $CUR -> $(basename "$PREV")"

            # Reload services (best effort)
            if command -v systemctl >/dev/null 2>&1; then
              sudo -n systemctl reload nginx 2>/dev/null || true
            fi
            sudo -n service php8.3-fpm reload 2>/dev/null || true

            echo "‚úÖ Rollback completed"
          '

          echo "‚úÖ Auto-rollback executed successfully"

      - name: Verify rollback (non-blocking)
        if: failure()
        continue-on-error: true
        env:
          DOMAIN: ${{ env.DOMAIN }}
          HEALTHCHECK_TOKEN: ${{ secrets.HEALTHCHECK_TOKEN }}
        run: |
          echo "üîç Verifying application health after rollback..."
          echo ""

          # Show current release
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" /bin/bash -lc '
            BASE="/var/www/api-gateway-staging"
            echo "Current release: $(readlink -f "$BASE/current")"
            echo ""
            echo "Last 2 releases:"
            ls -1dt "$BASE"/releases/* | head -2
          '

          echo ""
          echo "Testing health endpoints..."

          # Test /health
          code=$(curl -sS -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer $HEALTHCHECK_TOKEN" \
            "https://$DOMAIN/health" 2>/dev/null || echo "000")
          echo "Rollback health /health: HTTP $code"

          # Test /api/health-check
          code2=$(curl -sS -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer $HEALTHCHECK_TOKEN" \
            "https://$DOMAIN/api/health-check" 2>/dev/null || echo "000")
          echo "Rollback health /api/health-check: HTTP $code2"

          # Test /healthcheck.php
          code3=$(curl -sS -o /dev/null -w "%{http_code}" \
            "https://$DOMAIN/healthcheck.php" 2>/dev/null || echo "000")
          echo "Rollback health /healthcheck.php: HTTP $code3"

          if [ "$code" = "200" ] && [ "$code2" = "200" ] && [ "$code3" = "200" ]; then
            echo "‚úÖ Application healthy after rollback"
          else
            echo "‚ö†Ô∏è Some health checks failed - manual verification recommended"
          fi
