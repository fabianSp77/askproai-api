# ==============================================================================
# Deploy to Staging (fixed)
# ==============================================================================

name: Deploy to Staging

on:
  workflow_run:
    workflows: ["Build Artifacts"]
    types: [completed]
    branches: [develop]
  workflow_dispatch:
    inputs:
      build_run_id:
        description: 'Optional Build Run ID (defaults to latest successful build)'
        required: false
        type: string

env:
  STAGING_HOST: 152.53.116.127
  STAGING_USER: deploy
  STAGING_BASE_DIR: /var/www/api-gateway-staging
  DOMAIN: staging.askproai.de

jobs:
  # ==========================================================================
  # SSH Secret Validation (Fail-Fast)
  # ==========================================================================
  validate-ssh-secret:
    name: Validate SSH Secret
    runs-on: ubuntu-latest
    timeout-minutes: 5
    environment: staging

    steps:
      - name: Validate STAGING_SSH_KEY Format
        run: |
          echo "üîç Validating STAGING_SSH_KEY format..."

          # Check if secret exists
          if [ -z "${{ secrets.STAGING_SSH_KEY }}" ]; then
            echo "‚ùå STAGING_SSH_KEY secret is empty or not set"
            echo "Please configure STAGING_SSH_KEY in GitHub repository secrets"
            exit 1
          fi

          # Write secret to temp file
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          printf '%s\n' "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/staging_key
          chmod 600 ~/.ssh/staging_key

          # Check for BEGIN marker
          if ! head -n1 ~/.ssh/staging_key | grep -q "BEGIN"; then
            echo "‚ùå Secret does not start with BEGIN marker"
            echo "Expected: -----BEGIN OPENSSH PRIVATE KEY-----"
            echo "Got: $(head -n1 ~/.ssh/staging_key | head -c 50)..."
            exit 1
          fi

          # Count lines
          LINE_COUNT=$(wc -l < ~/.ssh/staging_key)
          echo "üìä Key has $LINE_COUNT lines"

          if [ "$LINE_COUNT" -lt 5 ]; then
            echo "‚ùå Key seems too short (< 5 lines)"
            echo "Please ensure STAGING_SSH_KEY is a complete OpenSSH private key"
            echo "Note: Ed25519 keys are typically 5-7 lines, RSA keys 10+ lines"
            exit 1
          fi

          # Extract fingerprint
          if ! FINGERPRINT=$(ssh-keygen -lf ~/.ssh/staging_key 2>&1); then
            echo "‚ùå Invalid SSH key format"
            echo "Error: $FINGERPRINT"
            exit 1
          fi

          echo "‚úÖ SSH secret validation passed"
          echo "üìã Fingerprint: $FINGERPRINT"

  # ==========================================================================
  # SSH Reachability Check
  # ==========================================================================
  dry-run-ssh:
    name: SSH Reachability Test
    runs-on: ubuntu-latest
    needs: [validate-ssh-secret]
    timeout-minutes: 5
    environment: staging

    steps:
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          printf '%s\n' "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/staging_key
          chmod 600 ~/.ssh/staging_key

      - name: Test SSH Connection
        run: |
          echo "üîå Testing SSH connection to ${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}..."

          # Add host to known_hosts
          ssh-keyscan -H ${{ env.STAGING_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

          # Try SSH connection
          if ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
              ${{ env.STAGING_USER }}@${{ env.STAGING_HOST }} "echo 'SSH connection successful!'" 2>&1; then
            echo "‚úÖ SSH connection works!"
            echo "üéØ Ready for deployment"
          else
            echo "‚ùå SSH connection failed"
            echo ""
            echo "Possible causes:"
            echo "  1. User 'deploy' does not exist on server"
            echo "  2. Public key not in /home/deploy/.ssh/authorized_keys"
            echo "  3. Incorrect permissions on .ssh directory or authorized_keys"
            echo "  4. SSH daemon configuration blocking pubkey authentication"
            echo ""
            echo "To fix, run these commands on the staging server as root:"
            echo "  id -u deploy >/dev/null 2>&1 || adduser --disabled-password --gecos '' deploy"
            echo "  install -d -m 700 -o deploy -g deploy /home/deploy/.ssh"
            echo "  echo 'YOUR_PUBLIC_KEY' >> /home/deploy/.ssh/authorized_keys"
            echo "  chown deploy:deploy /home/deploy/.ssh/authorized_keys"
            echo "  chmod 600 /home/deploy/.ssh/authorized_keys"
            exit 1
          fi

  # ==========================================================================
  # Deploy to Staging
  # ==========================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [dry-run-ssh]
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    timeout-minutes: 30
    environment:
      name: staging
      url: https://staging.askproai.de

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure tools
        run: |
          type jq >/dev/null 2>&1 || { sudo apt-get update && sudo apt-get install -y jq; }
          type gh >/dev/null 2>&1 || { echo "gh CLI fehlt (Runner)"; exit 1; }

      - name: Determine Build Run ID
        id: build_run
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ -n "${{ github.event.workflow_run.id || '' }}" ]; then
            BUILD_RUN_ID="${{ github.event.workflow_run.id }}"
            BUILD_SHA="${{ github.event.workflow_run.head_sha }}"
          elif [ -n "${{ inputs.build_run_id || '' }}" ]; then
            BUILD_RUN_ID="${{ inputs.build_run_id }}"
            BUILD_SHA=$(gh run view "$BUILD_RUN_ID" --json headSha --jq '.headSha')
          else
            SHA="${{ github.sha }}"
            BUILD_RUN_ID=$(gh run list \
              --workflow "Build Artifacts" \
              --branch "${{ github.ref_name }}" \
              --json databaseId,headSha,status,conclusion \
              --limit 20 | jq -r --arg sha "$SHA" \
              '[.[] | select(.headSha==$sha and .status=="completed" and .conclusion=="success")][0].databaseId')
            [ -z "$BUILD_RUN_ID" ] && { echo "No successful Build Artifacts run for SHA"; exit 1; }
            BUILD_SHA="$SHA"
          fi
          echo "BUILD_RUN_ID=$BUILD_RUN_ID" >> $GITHUB_ENV
          echo "BUILD_SHA=$BUILD_SHA"       >> $GITHUB_ENV
          echo "run_id=$BUILD_RUN_ID"       >> $GITHUB_OUTPUT
          echo "sha=$BUILD_SHA"             >> $GITHUB_OUTPUT

      - name: Download Deployment Bundle
        uses: actions/download-artifact@v4
        with:
          name: deployment-bundle-${{ env.BUILD_SHA }}
          path: ./bundle/
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ env.BUILD_RUN_ID }}

      - name: Inspect Bundle
        run: |
          echo "üì¶ Bundle contents:"
          ls -lh bundle/

          echo ""
          echo "‚úÖ Verifying checksum..."
          cd bundle
          sha256sum -c *.sha256
          cd ..

          echo "‚úÖ Bundle verified successfully"

      - name: Write SSH key from secret
        run: |
          [ -n "${{ secrets.STAGING_SSH_KEY }}" ] || { echo "STAGING_SSH_KEY missing"; exit 1; }
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          printf '%s\n' "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/staging_key
          chmod 600 ~/.ssh/staging_key
          head -n1 ~/.ssh/staging_key | grep -q "BEGIN OPENSSH PRIVATE KEY" || { echo "Invalid key format"; exit 1; }

      - name: Setup known_hosts
        run: |
          ssh-keyscan -H ${{ env.STAGING_HOST }} >> ~/.ssh/known_hosts 2>&1
          ssh-keyscan -H ${{ env.DOMAIN }}       >> ~/.ssh/known_hosts 2>&1 || true

      - name: Upload bundle to server
        run: |
          set -euo pipefail
          BUNDLE_FILE=$(ls bundle/deployment-bundle-*.tar.gz)
          BUNDLE_NAME=$(basename "$BUNDLE_FILE")
          scp -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "$BUNDLE_FILE" "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}:/tmp/"
          echo "BUNDLE_NAME=$BUNDLE_NAME" >> $GITHUB_ENV
          echo "‚úÖ Uploaded $BUNDLE_NAME"

      - name: Prepare release on server
        run: |
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" << EOF
          set -euo pipefail
          TIMESTAMP=\$(date +%Y%m%d_%H%M%S)
          COMMIT_SHA="${{ env.BUILD_SHA }}"
          COMMIT_SHA_SHORT=\${COMMIT_SHA:0:8}
          RELEASE_NAME="\${TIMESTAMP}-\${COMMIT_SHA_SHORT}"
          RELEASE_PATH="${{ env.STAGING_BASE_DIR }}/releases/\${RELEASE_NAME}"
          mkdir -p "\$RELEASE_PATH"
          tar -xzf "/tmp/${BUNDLE_NAME}" -C "\$RELEASE_PATH"
          cd "\$RELEASE_PATH"
          rm -rf storage && ln -s "${{ env.STAGING_BASE_DIR }}/shared/storage" storage
          rm -rf public/uploads && ln -s "${{ env.STAGING_BASE_DIR }}/shared/public/uploads" public/uploads
          ln -s "${{ env.STAGING_BASE_DIR }}/shared/.env/staging.env" .env
          chmod -R 775 bootstrap/cache
          echo "RELEASE_PATH=\$RELEASE_PATH" > /tmp/deploy_env
          EOF

      - name: Verify Release Structure (Pre-Switch Gate)
        run: |
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" << 'EOF'
          set -euo pipefail
          source /tmp/deploy_env
          cd "$RELEASE_PATH"

          echo "üîé Verifying release structure before migrations..."
          echo ""

          # Critical Laravel files
          test -f artisan || { echo "‚ùå PRE-SWITCH GATE FAILED: artisan missing"; exit 1; }
          test -f composer.json || { echo "‚ùå PRE-SWITCH GATE FAILED: composer.json missing"; exit 1; }

          # Public entry point (CRITICAL!)
          test -f public/index.php || { echo "‚ùå PRE-SWITCH GATE FAILED: public/index.php MISSING!"; exit 1; }
          test -f public/build/manifest.json || { echo "‚ùå PRE-SWITCH GATE FAILED: build/manifest.json missing"; exit 1; }

          # Vendor autoload (CRITICAL!)
          test -f vendor/autoload.php || { echo "‚ùå PRE-SWITCH GATE FAILED: vendor/autoload.php MISSING!"; exit 1; }

          # Directory structure
          test -d bootstrap || { echo "‚ùå PRE-SWITCH GATE FAILED: bootstrap/ missing"; exit 1; }
          test -d config || { echo "‚ùå PRE-SWITCH GATE FAILED: config/ missing"; exit 1; }
          test -d routes || { echo "‚ùå PRE-SWITCH GATE FAILED: routes/ missing"; exit 1; }
          test -d app || { echo "‚ùå PRE-SWITCH GATE FAILED: app/ missing"; exit 1; }

          # PHP Autoload test (CRITICAL!)
          php -r "require 'vendor/autoload.php'; echo 'autoload-ok';" | grep -q autoload-ok || {
            echo "‚ùå PRE-SWITCH GATE FAILED: Autoload broken"
            exit 1
          }

          # Artisan test (CRITICAL!)
          echo "Testing artisan..."
          if php artisan --version 2>&1 | head -5; then
            echo "‚úÖ Artisan working"
          else
            echo "‚ùå PRE-SWITCH GATE FAILED: artisan failed"
            echo "Debug info:"
            ls -la artisan .env 2>&1 || true
            php -v 2>&1 | head -2 || true
            exit 1
          fi

          echo "‚úÖ All pre-switch gates PASSED"
          echo ""
          echo "Release structure verified:"
          ls -lah public/ | grep index.php
          ls -lah vendor/ | grep autoload.php
          echo ""
          echo "‚úÖ Release is safe for deployment"
          EOF

      - name: Run migrations
        run: |
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" << 'EOF'
          set -euo pipefail
          source /tmp/deploy_env
          cd "$RELEASE_PATH"
          mkdir -p "${STAGING_BASE_DIR:-/var/www/api-gateway-staging}/shared/storage/backups"
          php artisan migrate --force
          EOF

      - name: Clear caches
        run: |
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" << 'EOF'
          set -euo pipefail
          source /tmp/deploy_env
          cd "$RELEASE_PATH"
          php artisan config:clear || true
          php artisan cache:clear  || true
          php artisan route:clear  || true
          php artisan view:clear   || true
          php artisan optimize:clear || true
          php artisan config:cache || true
          php artisan route:cache  || true
          EOF

      # Storage permissions are configured during initial server setup
      # No sudo required during deployment (least privilege principle)

      - name: Switch current symlink
        run: |
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" << 'EOF'
          set -euo pipefail
          source /tmp/deploy_env
          CURRENT_LINK="${STAGING_BASE_DIR:-/var/www/api-gateway-staging}/current"
          TEMP_LINK="${CURRENT_LINK}_tmp_$$"
          ln -s "$RELEASE_PATH" "$TEMP_LINK"
          mv -Tf "$TEMP_LINK" "$CURRENT_LINK"
          EOF

      - name: Reload services
        run: |
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" << 'EOF'
          set -euo pipefail

          echo "üîÑ Reloading services (passwordless sudo)..."

          # Detect PHP-FPM version
          PHP_FPM_SERVICE=$(systemctl list-units --type=service | grep -o 'php[0-9.]*-fpm' | head -1)

          if [ -n "$PHP_FPM_SERVICE" ]; then
            echo "Reloading $PHP_FPM_SERVICE..."
            sudo -n service $PHP_FPM_SERVICE reload
            echo "‚úÖ PHP-FPM reloaded"
          else
            echo "‚ö†Ô∏è No PHP-FPM service detected"
          fi

          # Reload NGINX (try systemctl first, fallback to service)
          echo "Reloading NGINX..."
          if sudo -n systemctl reload nginx 2>/dev/null; then
            echo "‚úÖ NGINX reloaded (systemctl)"
          elif sudo -n service nginx reload 2>/dev/null; then
            echo "‚úÖ NGINX reloaded (service)"
          else
            echo "‚ùå NGINX reload failed"
            exit 1
          fi
          EOF

      - name: Post-Deploy Verification
        run: |
          echo "üè• Running comprehensive post-deploy verification..."
          echo ""

          if [ -z "${{ secrets.HEALTHCHECK_TOKEN || '' }}" ]; then
            echo "‚ùå HEALTHCHECK_TOKEN not configured"
            exit 1
          fi

          TOKEN="${{ secrets.HEALTHCHECK_TOKEN }}"
          DOMAIN="${{ env.DOMAIN }}"
          FAILED=0

          # Test 1: healthcheck.php (standalone, no Laravel)
          echo "1Ô∏è‚É£  Testing /healthcheck.php..."
          HTTP_CODE=$(curl -sS -o /tmp/health1.json -w "%{http_code}" \
            -H "Authorization: Bearer $TOKEN" "https://$DOMAIN/healthcheck.php")
          if [ "$HTTP_CODE" = "200" ] && jq -e '.status == "healthy"' /tmp/health1.json > /dev/null; then
            echo "   ‚úÖ healthcheck.php: 200 OK"
          else
            echo "   ‚ùå healthcheck.php: HTTP $HTTP_CODE"
            FAILED=1
          fi

          # Test 2: /health (Laravel route)
          echo "2Ô∏è‚É£  Testing /health..."
          HTTP_CODE=$(curl -sS -o /tmp/health2.json -w "%{http_code}" \
            -H "Authorization: Bearer $TOKEN" "https://$DOMAIN/health")
          if [ "$HTTP_CODE" = "200" ] && jq -e '.status == "healthy"' /tmp/health2.json > /dev/null; then
            echo "   ‚úÖ /health: 200 OK"
          else
            echo "   ‚ùå /health: HTTP $HTTP_CODE"
            FAILED=1
          fi

          # Test 3: /api/health-check (API endpoint)
          echo "3Ô∏è‚É£  Testing /api/health-check..."
          HTTP_CODE=$(curl -sS -o /tmp/health3.json -w "%{http_code}" \
            -H "Authorization: Bearer $TOKEN" "https://$DOMAIN/api/health-check")
          if [ "$HTTP_CODE" = "200" ] && jq -e '.status == "healthy"' /tmp/health3.json > /dev/null; then
            echo "   ‚úÖ /api/health-check: 200 OK"
          else
            echo "   ‚ùå /api/health-check: HTTP $HTTP_CODE"
            FAILED=1
          fi

          echo ""
          if [ "$FAILED" -eq 1 ]; then
            echo "‚ùå Post-deploy verification FAILED - will trigger auto-rollback"
            exit 1
          fi

          echo "‚úÖ All health checks passed"

      - name: Vite Asset Validation
        run: |
          echo "üì¶ Validating Vite build artifacts..."

          # Check manifest.json exists and is valid JSON
          MANIFEST_URL="https://${{ env.DOMAIN }}/build/manifest.json"

          if curl -sSf "$MANIFEST_URL" | jq empty; then
            echo "‚úÖ Vite manifest.json is valid"
          else
            echo "‚ùå Vite manifest.json is invalid or missing"
            exit 1
          fi

          # Check at least one asset exists
          ASSET_PATH=$(curl -sSf "$MANIFEST_URL" | jq -r 'to_entries | .[0].value.file')
          ASSET_URL="https://${{ env.DOMAIN }}/build/${ASSET_PATH}"

          if curl -sSf -I "$ASSET_URL" > /dev/null; then
            echo "‚úÖ Vite assets are accessible"
          else
            echo "‚ùå Vite assets not found"
            exit 1
          fi

      - name: Create Deployment Ledger
        run: |
          echo "üìù Creating deployment ledger with SHA256 verification..."

          # Get bundle SHA256
          BUNDLE_SHA256=$(cat bundle/*.sha256 | awk '{print $1}')

          # Create ledger entry
          cat > deployment-ledger.json << LEDGER
          {
            "deployment_id": "${{ github.run_id }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "environment": "staging",
            "commit_sha": "${{ env.BUILD_SHA }}",
            "commit_sha_short": "${BUILD_SHA:0:8}",
            "bundle_name": "${BUNDLE_NAME}",
            "bundle_sha256": "${BUNDLE_SHA256}",
            "deployed_by": "${{ github.actor }}",
            "trigger": "${{ github.event_name }}",
            "health_checks": {
              "healthcheck_php": "passed",
              "health_endpoint": "passed",
              "api_health_check": "passed",
              "vite_assets": "passed"
            },
            "workflow_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          LEDGER

          echo "‚úÖ Deployment ledger created"
          cat deployment-ledger.json | jq '.'

      - name: Upload Deployment Ledger
        uses: actions/upload-artifact@v4
        with:
          name: deployment-ledger-${{ github.run_id }}
          path: deployment-ledger.json
          retention-days: 90

      - name: Cleanup temp
        if: always()
        run: |
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" << EOF
          rm -f "/tmp/${BUNDLE_NAME}" || true
          rm -f /tmp/deploy_env || true
          EOF

  # ==========================================================================
  # Auto-Rollback on Deployment Failure
  # ==========================================================================
  auto-rollback:
    name: Auto-Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: failure() && (github.event_name == 'workflow_run' || github.event_name == 'workflow_dispatch')
    timeout-minutes: 10
    environment: staging

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Write SSH key from secret
        run: |
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          printf '%s\n' "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/staging_key
          chmod 600 ~/.ssh/staging_key

      - name: Setup known_hosts
        run: |
          ssh-keyscan -H ${{ env.STAGING_HOST }} >> ~/.ssh/known_hosts 2>&1

      - name: Execute Rollback
        run: |
          echo "üîÑ Deployment failed! Executing auto-rollback..."

          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no \
            "${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}" /bin/bash -lc '
            set -euo pipefail
            BASE="/var/www/api-gateway-staging"
            CUR="$BASE/current"
            REL="$BASE/releases"

            # Verify current symlink exists
            test -L "$CUR" || { echo "‚ùå No current deployment found"; exit 1; }

            # Get current and previous releases
            NOW="$(readlink -f "$CUR")"
            PREV="$(ls -1dt "$REL"/* | grep -v "$(basename "$NOW")" | head -1)"

            # Verify previous release exists
            test -d "$PREV" || { echo "‚ùå No previous release found"; exit 1; }

            echo "üìã Rollback Plan:"
            echo "  From: $(basename "$NOW")"
            echo "  To:   $(basename "$PREV")"

            # Perform rollback
            ln -snf "$PREV" "$CUR"
            echo "‚úÖ Updated symlink: $CUR -> $(basename "$PREV")"

            # Reload services (best effort)
            if command -v systemctl >/dev/null 2>&1; then
              sudo -n systemctl reload nginx 2>/dev/null || true
            fi
            sudo -n service php8.3-fpm reload 2>/dev/null || true

            echo "‚úÖ Rollback completed"
          '

          echo "‚úÖ Auto-rollback executed successfully"

      - name: Verify Rollback
        run: |
          echo "üîç Verifying application health after rollback..."

          sleep 3

          if [ -n "${{ secrets.HEALTHCHECK_TOKEN || '' }}" ]; then
            HEALTH_CHECK=$(curl -sf -H "Authorization: Bearer ${{ secrets.HEALTHCHECK_TOKEN }}" \
              "https://${{ env.DOMAIN }}/health" || echo "fail")
          else
            HEALTH_CHECK=$(curl -sf "https://${{ env.DOMAIN }}/health" || echo "fail")
          fi

          if [[ "${HEALTH_CHECK}" == "fail" ]]; then
            echo "‚ùå Rollback verification failed - manual intervention required!"
            exit 1
          fi

          echo "‚úÖ Application healthy after rollback"
